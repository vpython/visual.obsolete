from math import pi, cos, sin, sqrt, tan, atan, acos
from Polygon import Polygon
from Polygon.Shapes import Star
import vis

from ttfquery import describe, glyphquery, glyph
import os, sys, glob

Default = "default"

## The following code, from here to the end of findSystemFonts, is from
## https://mail.enthought.com/pipermail/enthought-svn/2005-September/000724.html
## Authors: John Hunter <jdhunter at ace.bsd.uchicago.edu>
##          Paul Barrett <Barrett at STScI.Edu>

#  OS Font paths
MSFolders = \
    r'Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders'

MSFontDirectories   = [
    r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts',
    r'SOFTWARE\Microsoft\Windows\CurrentVersion\Fonts']

X11FontDirectories  = [
    # what seems to be the standard installation point
    "/usr/X11R6/lib/X11/fonts/TTF/",
    # documented as a good place to install new fonts...
    "/usr/share/fonts/",
    # common application, not really useful
    "/usr/lib/openoffice/share/fonts/truetype/",
    ]

OSXFontDirectories = [
    "/Library/Fonts/",
    "/Network/Library/Fonts/",
    "/System/Library/Fonts/"
]

home = os.environ.get('HOME')
if home is not None:
    # user fonts on OSX
    path = os.path.join(home, 'Library', 'Fonts')
    OSXFontDirectories.append(path)

def win32FontDirectory():
    """Return the user-specified font directory for Win32."""

    imported = False
    try:
        import winreg as wreg
        imported = True
    except ImportError:
        pass
    if not imported:
        try:
            import _winreg as wreg
            imported = True
        except ImportError:
            return os.path.join(os.environ['WINDIR'], 'Fonts')
    if imported:
        user = wreg.OpenKey(wreg.HKEY_CURRENT_USER, MSFolders)
        try:
            return wreg.QueryValueEx(user, 'Fonts')[0]
        finally:
            wreg.CloseKey(user)
    return None

def win32InstalledFonts(directory=None, fontext='ttf'):
    """Search for fonts in the specified font directory, or use the
system directories if none given.  A list of TrueType fonts are
returned by default with AFM fonts as an option.
"""

    if directory is None:
        directory = win32FontDirectory()

    imported = False
    try:
        import winreg as wreg
        imported = True
    except ImportError:
        pass
    if not imported:
        try:
            import _winreg as wreg
            imported = True
        except ImportError:
            raise ImportError("Cannot find winreg module")

    key, items = None, {}
    for fontdir in MSFontDirectories:
        try:
            local = wreg.OpenKey(wreg.HKEY_LOCAL_MACHINE, fontdir)
        except OSError:
            continue

        if not local:
            return glob.glob(os.path.join(directory, '*.'+fontext))
        try:
            for j in range(wreg.QueryInfoKey(local)[1]):
                try:
                    key, direc, any = wreg.EnumValue( local, j)
                    if not os.path.dirname(direc):
                        direc = os.path.join(directory, direc)
                    direc = os.path.abspath(direc).lower()
                    if direc[-4:] == '.'+fontext:
                        items[direc] = 1
                except EnvironmentError:
                    continue
                except WindowsError:
                    continue

            return list(items.keys())
        finally:
            wreg.CloseKey(local)
    return None

def OSXFontDirectory():
    """Return the system font directories for OS X."""

    fontpaths = []
    for fontdir in OSXFontDirectories:
        try:
            if os.path.isdir(fontdir):
                for root, dirs, files in os.walk(fontdir):
                    fontpaths.append(root)
        except (IOError, OSError, TypeError, ValueError):
            pass
    return fontpaths

def OSXInstalledFonts(directory=None, fontext=None):
    """Get list of font files on OS X - ignores font suffix by default"""
    if directory is None:
        directory = OSXFontDirectory()

    files = []
    for path in directory:
        if fontext is None:
            files.extend(glob.glob(os.path.join(path,'*')))
        else:
            files.extend(glob.glob(os.path.join(path, '*.'+fontext)))
            files.extend(glob.glob(os.path.join(path, '*.'+fontext.upper())))
    return files


def x11FontDirectory():
    """Return the system font directories for X11."""
    fontpaths = []
    for fontdir in X11FontDirectories:
        try:
            if os.path.isdir(fontdir):
                for root, dirs, files in os.walk(fontdir):
                    fontpaths.append(root)
        except (IOError, OSError, TypeError, ValueError):
            pass
    return fontpaths

def findSystemFonts(fontpaths=None, fontext='ttf'):

    """Search for fonts in the specified font paths, or use the system
paths if none given.  A list of TrueType fonts are returned by default
with AFM fonts as an option.
"""

    fontfiles = {}

    if fontpaths is None:

        if sys.platform == 'win32':
            fontdir = win32FontDirectory()

            fontpaths = [fontdir]
            # now get all installed fonts directly...
            for f in win32InstalledFonts(fontdir):
                base, ext = os.path.splitext(f)
                if len(ext)>1 and ext[1:].lower()==fontext:
                    fontfiles[f] = 1
        else:
            fontpaths = x11FontDirectory()
            # check for OS X & load its fonts if present
            if sys.platform == 'darwin':
                for f in OSXInstalledFonts(fontext=fontext):
                    fontfiles[f] = 1

    elif isinstance(fontpaths, str):
        fontpaths = [fontpaths]

    for path in fontpaths:
        files = glob.glob(os.path.join(path, '*.'+fontext))
        files.extend(glob.glob(os.path.join(path, '*.'+fontext.upper())))
        for fname in files:
            fontfiles[os.path.abspath(fname)] = 1

    return [fname for fname in list(fontfiles.keys()) if os.path.exists(fname)]

def findFont(font):
    flist = findSystemFonts()
    if font == "serif":
        font = "Times New Roman"
    elif font == "sans-serif" or font == "sans":
        font = "Verdana"
    elif font == "monospace":
        font = "Courier New"
    f = font.split('.')
    if f[-1] == 'ttf':
        font = font[:-4]
    font = font.split('/')[-1]
    font = font.split('\\')[-1]
    font = font.lower()+".ttf"
    match = None
    sans = None
    freesans = freeserif = freemono = None
    for f in flist:
        if f[-4:] != ".ttf": continue
        if sys.platform == 'win32':
            name = f.split('\\')[-1].lower()
        else:
            name = f.split('/')[-1].lower()
        if name == font:
            match = f
            break
        elif name == "verdana.ttf":
            sans = f
        elif name == "freesans.ttf": # Ubuntu Linux
            freesans = f
        elif name == "freeserif.ttf": # Ubuntu Linux
            freeserif = f
        elif name == "freemono.ttf": # Ubuntu Linux
            freemono = f
        elif len(font) > len(name):
            if name[:-4] == font[:len(name)-4]:
                if match is None:
                    match = f
                elif len(match) < len(name):
                    match = f
        elif len(name) > len(font):
            if font[:-4] == name[:len(font)-4]:
                if match is None:
                    match = f
                elif len(match) < len(font):
                    match = f
    if freesans and not sans:
        sans = freesans
    if freesans and not match and font.lower()[:7] == "verdana":
        match = freesans
    elif freeserif and not match and font.lower()[:5] == "times":
        match = freeserif
    elif freemono and not match and font.lower()[:7] == "courier":
        match = freemono
    if match is not None:
        return match
    elif sans:
        return sans
    else:
        raise ValueError('Cannot find font "'+font+'"')

def rotatep(p, pr, angle):
        '''Rotate a single point p angle radians around pr'''
        sinr, cosr = sin(angle), cos(angle)
        x, y, z = p
        xRel, yRel, zRel = pr
        newx = x * cosr - y * sinr - xRel * cosr + yRel * sinr + xRel
        newy = x * sinr + y * cosr - xRel * sinr - yRel * cosr + yRel
        pr = (newx, newy)
        return pr

def rotatecp(cp, pr, angle):
        '''Rotate point-set cp angle radians around pr'''
        sinr, cosr = sin(angle), cos(angle)
        cpr = []
        for p in cp:
                x, y = p
                xRel, yRel = pr
                newx = x * cosr - y * sinr - xRel * cosr + yRel * sinr + xRel
                newy = x * sinr + y * cosr - xRel * sinr - yRel * cosr + yRel
                cpr.append((newx, newy))
        return cpr

def roundc(cp, roundness=0.1, nseg=8, invert=False):

    vort = 0.0
    cp.pop()
    for i in range(len(cp)):
        i1 = (i+1)%len(cp)
        i2 = (i+2)%len(cp)
        v1 = vis.vector(cp[i1]) - vis.vector(cp[i])
        v2 = vis.vector(cp[(i2)%len(cp)]) - vis.vector(cp[i1])
        dv = vis.dot(v1,v2)
        vort += dv

    if vort > 0: cp.reverse()

    l = 999999
    
    for i in range(len(cp)):
        p1 = vis.vector(cp[i])
        p2 = vis.vector(cp[(i+1)%len(cp)])
        lm = vis.mag(p2-p1)
        if lm < l: l = lm

    r = l*roundness
    ncp = []
    lcp = len(cp)

    for i in range(lcp):
        i1 = (i+1)%lcp
        i2 = (i+2)%lcp
        
        w0 = vis.vector(cp[i])
        w1 = vis.vector(cp[i1])
        w2 = vis.vector(cp[i2])

        wrt = vis.cross((w1-w0),(w2-w0))

        v1 = w1-w0
        v2 = w1-w2
        rax = vis.norm(((vis.norm(v1)+vis.norm(v2))/2.0))
        angle = acos(vis.dot(vis.norm(v2),vis.norm(v1)))
        afl = 1.0
        if wrt[2] > 0: afl = -1.0
        angle2 = angle/2.0
        cc = r/sin(angle2)
        ccp = vis.vector(cp[i1]) - rax*cc
        tt = r/tan(angle2)
        t1 = vis.vector(cp[i1]) -vis.norm(v1)*tt
        t2 = vis.vector(cp[i1]) -vis.norm(v2)*tt

        ncp.append(tuple(t1)[0:2])
        nc = []
        a = 0
        dseg = afl*(pi-angle)/nseg
        if not invert:
            for i in range(nseg):
                nc.append(rotatep(t1, ccp, a))
                ncp.append(tuple(nc[-1])[0:2])
                a -= dseg
        else:
            dseg = afl*(angle)/nseg
            for i in range(nseg):
                nc.append(rotatep(t1, (cp[i1][0],cp[i1][1],0), a))
                ncp.append(tuple(nc[-1])[0:2])
                a += dseg
        ncp.append(tuple(t2)[0:2])
    ncp.append(ncp[0])
    return ncp

def rectangle(pos=(0,0), width=1.0, height=None, rotate=0.0, thickness=0, 
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        if height is None: height = width
        
        if thickness == 0:
            p0 = (pos[0]-width/2.0, pos[1]-height/2.0)
            p1 = (pos[0]-width/2.0, pos[1]+height/2.0)
            p2 = (pos[0]+width/2.0, pos[1]+height/2.0)
            p3 = (pos[0]+width/2.0, pos[1]-height/2.0)
            p4 = (pos[0]-width/2.0, pos[1]-height/2.0)

            cp = [p0, p1, p2, p3, p4]
            if rotate != 0.0: cp = rotatecp(cp, pos, rotate)
            if scale != 1.0: xscale = yscale = scale
            pp = Polygon(cp)
            if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
            if roundness > 0:
                cp = roundc(pp.contour(0), roundness=roundness, invert=invert)
                return Polygon(cp)
            else: return pp
        else:
            pp = rframe(pos=pos, width=width, height=height, thickness=thickness,
                       rotate=rotate, roundness=roundness, invert=invert,
                       scale=scale, xscale=xscale, yscale=yscale)
            return pp

def line(pos=(0,0), np=2, rotate=0.0, scale=1.0, xscale=1.0, yscale=1.0,
           thickness=None, start=(0,0), end=(0,-1), path=True):
        if thickness is None:
            thickness = 0.001
        cp = [] 
        vline = (vector(end)-vector(start)).norm()
        mline = mag(vector(end)-vector(start))
        for i in range(np):
            x = start[0] + (vline*i)[0]/float(np-1)*mline
            y = start[1] + (vline*i)[1]/float(np-1)*mline
            cp.append( (x+pos[0],y+pos[1]) )
        if rotate != 0.0: cp = rotatecp(cp, pos, rotate)
        if scale != 1.0: xscale = yscale = scale
        pp = Polygon(cp)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if not path:
                return pp
        else:
                return cp

def cross(pos=(0,0), width=1.0, thickness=0.2, rotate=0.0,
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):

        fsqr = rectangle(pos=pos, width=width)
        sqr1 = rectangle(pos=(pos[0]-(width+thickness)/4.0,
                                     pos[0]+(width+thickness)/4.0), width=(width-thickness)/2.0)
        sqr2 = rectangle(pos=(pos[0]+(width+thickness)/4.0,
                                     pos[0]+(width+thickness)/4.0), width=(width-thickness)/2.0)
        sqr3 = rectangle(pos=(pos[0]+(width+thickness)/4.0,
                                     pos[0]-(width+thickness)/4.0), width=(width-thickness)/2.0)
        sqr4 = rectangle(pos=(pos[0]-(width+thickness)/4.0,
                                     pos[0]-(width+thickness)/4.0), width=(width-thickness)/2.0)
        poly = fsqr - sqr1 -sqr2 -sqr3 -sqr4
        cp = poly.contour(0)
        cp.append(cp[0])
        if rotate != 0.0: cp = rotatecp(cp, pos, rotate)
        pp = Polygon(cp)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if roundness > 0:
                cp = roundc(pp.contour(0), roundness=roundness, invert=invert)
                return Polygon(cp)
        else: return pp

def rframe(pos=(0,0), width=1.0, height=None, thickness=None, rotate=0.0,
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        if height == None: height = width
        if thickness == Default or thickness == None: thickness = min(height,width)*0.2
        else: thickness = min(height,width)*thickness*2
        fsqr = rectangle(pos=pos, width=width, height=height)
        sqr1 = rectangle(pos=pos, width=(width-thickness), height=height-thickness)
        pp = fsqr - sqr1
        if rotate != 0.0: pp.rotate(rotate)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if roundness > 0:
                cp0 = pp.contour(0)
                cp0.append(cp0[0])
                cp0 = roundc(cp0, roundness=roundness, invert=invert)
                cp1 = pp.contour(1)
                cp1.append(cp1[0])
                cp1 = roundc(cp1, roundness=roundness, invert=invert)
                p1 = Polygon(cp0)
                p2 = Polygon(cp1)
                pp = p2-p1
                return pp
        else: return pp


def nframe(pos=(0,0), length=1.0, np=3, thickness=None, rotate=0.0,
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        if thickness == Default or thickness == None: thickness = length*0.2
        else: thickness = length*thickness*2
        fsqr = ngon(pos=pos, np=np, length=length)
        nga = (np-2)*pi/np
        angle = (pi/2 - nga)
        length2=length-thickness*cos(angle)
        csa = cos(angle)
        sqr1 = ngon(pos=pos, np=np, length=length-thickness/csa*2-thickness*tan(angle)*2)
        pp = fsqr - sqr1
        if rotate != 0.0: pp.rotate(rotate)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if roundness > 0:
                cp0 = pp.contour(0)
                cp0.append(cp0[0])
                cp0 = roundc(cp0, roundness=roundness, invert=invert)
                cp1 = pp.contour(1)
                cp1.append(cp1[0])
                cp1 = roundc(cp1, roundness=roundness, invert=invert)
                p1 = Polygon(cp0)
                p2 = Polygon(cp1)
                pp = p2-p1
                return pp
        else: return pp


def sframe(pos=(0,0), np=5, radius=1.0, iradius=None, thickness=None, rotate=0.0,
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        if iradius == None: iradius = 0.5*radius
        if thickness == None: thickness = 0.2*radius
        else: thickness = thickness*2*iradius
        fsqr = star(pos=pos, np=np, radius=radius, iradius=iradius)
        angle = pi/2 - (np-2)*pi/np
        sqr1 = star(pos=pos, np=np, radius=radius-thickness, iradius=(radius-thickness)*iradius/radius)
        pp = fsqr - sqr1
        if rotate != 0.0: pp.rotate(rotate)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if roundness > 0:
                cp0 = pp.contour(0)
                cp0.append(cp0[0])
                cp0 = roundc(cp0, roundness=roundness, invert=invert)
                cp1 = pp.contour(1)
                cp1.append(cp1[0])
                cp1 = roundc(cp1, roundness=roundness, invert=invert)
                p1 = Polygon(cp0)
                p2 = Polygon(cp1)
                pp = p2-p1
                return pp
        else: return pp

def trapezoid(pos=(0,0), width=2.0, height=1.0, top=None, rotate=0.0, thickness=0,
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        if top == None: top = width/2.0
        if thickness == 0:
            p0 = (pos[0]-width/2.0, pos[1]-height/2.0)
            p1 = (pos[0]-top/2.0, pos[1]+height/2.0)
            p2 = (pos[0]+top/2.0, pos[1]+height/2.0)
            p3 = (pos[0]+width/2.0, pos[1]-height/2.0)
            p4 = (pos[0]-width/2.0, pos[1]-height/2.0)

            cp = [p0, p1, p2, p3, p4]
            if rotate != 0.0: cp = rotatecp(cp, pos, rotate)
            if scale != 1.0: xscale = yscale = scale
            pp = Polygon(cp)
            if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
            if roundness > 0:
                    cp = roundc(pp.contour(0), roundness=roundness, invert=invert)
                    return Polygon(cp)
            else: return pp
        else:
            pp = trframe(pos=pos, width=width, height=height, thickness=thickness,
                       rotate=rotate, roundness=roundness, invert=invert,
                       top=top, scale=scale, xscale=xscale, yscale=yscale)
            return pp

def trframe(pos=(0,0), width=2.0, height=1.0, top=None, thickness=None, rotate=0.0,
              roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        if top == None: top = width/2.0
        if thickness == Default or thickness == None: thickness = min(height,top)*0.2
        else: thickness = min(height,top)*thickness*2
        fsqr = trapezoid(pos=pos, width=width, height=height, top=top)
        angle = atan((width-top)/2.0/height)
        db = (thickness)/cos(angle)
        sqr1 = trapezoid(pos=pos, width=(width-db-thickness*tan(angle)),
                                height=height-thickness, top=top-(db-thickness*tan(angle)))
        pp = fsqr - sqr1
        if rotate != 0.0: pp.rotate(rotate)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if roundness > 0:
                cp0 = pp.contour(0)
                cp0.append(cp0[0])
                cp0 = roundc(cp0, roundness=roundness, invert=invert)
                cp1 = pp.contour(1)
                cp1.append(cp1[0])
                cp1 = roundc(cp1, roundness=roundness, invert=invert)
                p1 = Polygon(cp0)
                p2 = Polygon(cp1)
                pp = p2-p1
                return pp
        else: return pp

        
def circle(pos=(0,0), radius=0.5, np=32, scale=1.0, xscale=1.0, yscale=1.0,
           thickness=0):
        if thickness == 0:
            cp = []
            seg = 2.0*pi/np
            for i in range(np):
                angle = i*seg
                x = radius*cos(angle) + pos[0]
                y = radius*sin(angle) + pos[1]
                cp.append((x,y))
            cp.append(cp[0])
            if scale != 1.0: xscale = yscale = scale
            pp = Polygon(cp)
            if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
            return pp
        else:
            if thickness == Default: thickness = radius*0.2
            pp = ring(pos=pos, radius=radius, np=np, scale=scale,
                      iradius=(radius-thickness), xscale=xscale, yscale=yscale)
            return pp

def arc(pos=(0,0), radius=0.5, np=32, rotate=0.0, scale=1.0, xscale=1.0, yscale=1.0,
           thickness=None, angle1=0.0, angle2=pi, path=False):
        if thickness is None:
            thickness = 0.0001*radius
        cp = []  # outer arc
        cpi = [] # inner arc
        seg = 2.0*pi/np
        nseg = int(abs((angle2-angle1))/seg)+1
        seg = (angle2-angle1)/nseg
        for i in range(nseg+1):
            x = cos(angle1+i*seg)
            y = sin(angle1+i*seg)
            cp.append( (radius*x+pos[0],radius*y+pos[1]) )
            cpi.append( ((radius-thickness)*x+pos[0],(radius-thickness)*y+pos[1]) )
        if not path:
                cpi.reverse()
                for p in cpi:
                    cp.append(p)
                cp.append(cp[0])
        if rotate != 0.0: cp = rotatecp(cp, pos, rotate)
        if scale != 1.0: xscale = yscale = scale
        pp = Polygon(cp)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if not path:
                return pp
        else:
                return list(pp)

def ring(pos=(0,0), radius=1.0, iradius=None, np=32, scale=1.0, xscale=1.0, yscale=1.0):
        if iradius == None: iradius = radius*0.8
        c1 = circle(pos=pos, radius=radius, np=np, scale=1.0, xscale=1.0, yscale=1.0)
        c2 = circle(pos=pos, radius=iradius, np=np, scale=1.0, xscale=1.0, yscale=1.0)
        pp = c1-c2
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        return pp

def ellipse(pos=(0,0), width=1.0, height=None, np=32, rotate=0.0,
            scale=1.0, xscale=1.0, yscale=1.0):
        if height == None: height = 0.5*width
        cp = []
        seg = 2.0*pi/np
        angle = 0
        radius=0.5
        lf = width/2.0
        hf = height/2.0
        for i in range(np):
            x = cos(angle)*lf + pos[0]
            y = sin(angle)*hf + pos[1]
            cp.append((x,y))
            angle += seg
        cp.append(cp[0])
        if rotate != 0.0: cp = rotatecp(cp, pos, rotate)
        if scale != 1.0: xscale = yscale = scale
        pp = Polygon(cp)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        return pp

def ering(pos=(0,0), width=1.0, height=None, np=32, scale=1.0, thickness=None, 
          xscale=1.0, yscale=1.0, rotate=0.0):
        if height == None: height = 0.5*width
        if thickness == Default or thickness == None: thickness = min(width,height)*0.2
        else: thickness = min(width,height)*thickness
        c1 = ellipse(pos=pos, width=width, height=height, np=np,
                     scale=1.0, xscale=1.0, yscale=1.0, rotate=rotate)
        c2 = ellipse(pos=pos, width=width-thickness, height=height-thickness,
                     np=np, scale=1.0, xscale=1.0, yscale=1.0, rotate=rotate)
        #pp = c1-c2
        c3 = ellipse(pos=pos, width=width, height=height, np=np,
                     scale=1.0, xscale=(width-thickness*height)/width,
                     yscale=1.0-thickness, rotate=rotate)
        pp = c1-c3
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        return pp
        
def ngon(pos=(0,0), np=3, length=None, radius=1.0, rotate=0.0, thickness=0,
         roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
        cp = [] 
        if np < 3:
                raise AttributeError,"number of sides can not be less than 3"
                return None

        angle = 2*pi/np
        if length != None: radius = (length/2.0)/(sin(angle/2))    
        else: length = radius*(sin(angle/2))*2
        if thickness == 0:
            seg = 2.0*pi/np
            angle = rotate
            for i in range(np):
                x = radius*cos(angle) + pos[0]
                y = radius*sin(angle) + pos[1]
                cp.append((x,y))
                angle += seg
            cp.append(cp[0])
            if scale != 1.0: xscale = yscale = scale
            pp = Polygon(cp)
            if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
            if roundness > 0:
                    cp = roundc(pp.contour(0), roundness=roundness, invert=invert)
                    return Polygon(cp)
            else: return pp
        else:
            pp = nframe(pos=pos, length=length, thickness=thickness, roundness=roundness,
                        invert=invert, rotate=rotate, np=np)
            return pp

def triangle(pos=(0,0), length=1.0, rotate=0.0, roundness=0.0, thickness=0,
             invert=False, scale=1.0, xscale=1.0, yscale=1.0):
    tri = ngon(pos=pos, np=3, length=length, rotate=rotate-pi/6.0,
               roundness=roundness, invert=invert, scale=scale,
               xscale=xscale, yscale=yscale, thickness=thickness)
    return Polygon(tri)

def pentagon(pos=(0,0), length=1.0, rotate=0.0, roundness=0.0, thickness=0,
             invert=False, scale=1.0, xscale=1.0, yscale=1.0):
    pen = ngon(pos=pos, np=5, length=length, rotate=rotate+pi/10,
               roundness=roundness, invert=invert, scale=scale,
               xscale=xscale, yscale=yscale, thickness=thickness)
    return Polygon(pen)

def hexagon(pos=(0,0), length=1.0, rotate=0.0, roundness=0.0, thickness=0,
            invert=False, scale=1.0, xscale=1.0, yscale=1.0):
    hxg = ngon(pos=pos, np=6, length=length, rotate=rotate,
               roundness=roundness, invert=invert, scale=scale,
               xscale=xscale, yscale=yscale, thickness=thickness)
    return Polygon(hxg)

def star(pos=(0,0), radius=1.0, np=5, iradius=None, rotate=0.0, thickness=0.0,
         roundness=0.0, invert=False, scale=1.0, xscale=1.0, yscale=1.0):
    if iradius == None: iradius = radius*0.5
    if thickness == 0.0:
        pstar = Star(radius=radius, center=pos, beams=np, iradius=iradius)
        cp = pstar[0]
        cp.append(cp[0])
        cp = rotatecp(cp, pos, rotate)
        if scale != 1.0: xscale = yscale = scale
        pp = Polygon(cp)
        if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
        if roundness > 0:
            cp = roundc(pp.contour(0), roundness=roundness, invert=invert)
            return Polygon(cp)
        else: return pp
    else:
        pp = sframe(pos=pos, radius=radius, iradius=iradius, rotate=rotate,
                    thickness=thickness, roundness=roundness, invert=invert,
                    scale=scale, xscale=xscale, yscale=yscale, np=np)
        return pp

def pointlist(pos=[], rotate=0.0, roundness=0.0, invert=False,
              scale=1.0, xscale=1.0, yscale=1.0, path=False):
    # pos may be either a list of points or a Polygon object
    try:
        points = pos.contour(0)
        if len(pos) > 1:
            raise AttributeError("pointlist can deal with only a single contour.")
    except:
        points = pos[:]
    closed = (points[-1] == points[0])
    if not closed:
        points.append(points[0])
    pp = Polygon(points)
    if len(pp) and rotate != 0.0: pp.rotate(rotate)
    if scale != 1.0: xscale = yscale = scale
    if xscale != 1.0 or yscale != 1.0: pp.scale(xscale,yscale)
    if roundness > 0:
        cp = roundc(pp.contour(0), roundness=roundness, invert=invert)
        pp = Polygon(cp)
    if path:
        if closed:
            return list(pp)
        else:
            return list(pp)[:-1]
    else:
        return pp
    
            
def text(pos=(0,0), text="", font=None, height=1.0, align='left', spacing=0.03,
         rotate=0.0, scale=1.0, xscale=1.0, yscale=1.0, thickness=None, vertical_spacing=None):
    if thickness is not None:
        raise AttributeError("Thickness is not allowed in a text shape.")
    if scale != 1.0: xscale = yscale = scale
    lines = text.split('\n')
    while lines[-1] == '\n': # strip off trailing newlines
        lines = lines[:-1]
    if font is None:
        font = "serif"
    font = describe.openFont(findFont(font))
    
    try:
        fonth = glyphquery.charHeight(font)
    except:
        fonth = 1000
    if fonth == 0: fonth = 1000
    
    try:
        desc = glyphquery.charDescent(font) # charDescent may not be present
        fontheight = fonth+desc
        fontscale = 1./fontheight
        descent = fontscale*desc
    except:
        descent = -0.3*height # approximate value
        fontheight = 0.7*fonth
        fontscale = 1.3/fontheight
        
    if vertical_spacing is None:
        vertical_spacing = height*fontscale*glyphquery.lineHeight(font)
    print vertical_spacing

    excludef_list = [("ITCEdscr")]
    excludec_list = [("FRSCRIPT", "A"), ("jokerman", "O"),
                    ("vivaldii", "O"), ("vivaldii", "Q"),
                    ("vivaldii", "R")]
    
    ptext = [] 
    widths = []
    width = 0.0
    starts = []
    start = 0.0

    for line in range(len(lines)):
        ptext.append(Polygon())
        bb = 0
        
        for newchar in lines[line]:
            if newchar == " ":
                try:
                    if a:
                        bx = a.boundingBox()
                        bba = bx[1]-bx[0]
                        bba = min(bba, 700)
                        bb += bba
                except:
                    pass
                continue
            n = glyphquery.glyphName(font, newchar)

            if n == ".notdef":
                print("The character '"+newchar+"' is not supported in the font "+font)
                continue
            
            g = glyph.Glyph(n)
            c = g.calculateContours(font)
            contours = []

            for contour in c:
                contours.append(glyph.decomposeOutline(contour))
                if len(contours[-1]) == 0: contours.pop()

            for contour in contours:
                pp = 0
                for i in range(len(contour)-1):
                    if (contour[i][0] == contour[i+1][0]) and (contour[i][1] == contour[i+1][1]):
                        contour.pop(i)
                        pp += 1
                        if i+pp >= len(contour)-1: break

            def lenctr(contour):
                totlen = 0
                for j in range(len(contour)-1):
                    totlen += (vector(contour[j])-vector(contour[j+1])).mag
                return totlen

            lc = len(contours)
            
            if lc >= 4:
                mli = 0
                maxl = 0
                lengths = []
                for i in range(len(contours)):
                    totlen = lenctr(contours[i])
                    lengths.append((totlen,i))
                    if totlen > maxl:
                        mli = i
                        maxl = totlen

                lengths.sort()
                lengths.reverse()
                ocontours = []
                for ll in lengths:
                    ocontours.append(contours[ll[1]])
                contours = ocontours

                indxf = -1
                indxc = -1
                if (mli > 0 and newchar != "%"):
                    try: indxf = excludef_list.index(self.font)
                    except: pass
                    if indxf == -1:
                        try: indxc = excludec_list.index((self.font, newchar))
                        except: pass
                    if (indxf == -1 and indxc == -1):
                        maxc = contours.pop(mli)
                        contours.insert(0, maxc)
                               
            a = Polygon(contours[0])
            for i in range(1,len(contours)):
                b = Polygon(contours[i])
                if a.covers(b): a = a - b
                elif b.covers(a): a = b - a
                else: a = a + b

            a.shift(bb - a.boundingBox()[0] ,0)
           
            ptext[line] += a
            
            bx = ptext[line].boundingBox()
            bb = bx[1] - bx[0] + spacing*fontheight

        newwidth = fontscale*height*(ptext[line].boundingBox()[1]-ptext[line].boundingBox()[0])
        widths.append(newwidth)
        if newwidth > width: width = newwidth
        
        ptext[line].scale(xscale*fontscale*height, yscale*fontscale*height, 0, 0)
        
    upper_left = []
    upper_right = []
    lower_left = []
    lower_right = []
    for line in range(len(lines)):
        if align == 'left':
            ptext[line].shift(-width/2,-line*vertical_spacing)
        elif align == 'right':
            ptext[line].shift(width/2-widths[line],-line*vertical_spacing)
        else:
            ptext[line].shift(-widths[line]/2,-line*vertical_spacing)
        ptext[line].shift(pos[0], pos[1])
        if rotate != 0.0: ptext[line].rotate(rotate)
        if line == 0:
            shape = ptext[0]
        else:
            shape += ptext[line]
        upper_left.append(vis.vector(ptext[line].boundingBox()[0],ptext[line].boundingBox()[3],0))
        upper_right.append(vis.vector(ptext[line].boundingBox()[1],ptext[line].boundingBox()[3],0))
        lower_left.append(vis.vector(ptext[line].boundingBox()[0],ptext[line].boundingBox()[2],0))
        lower_right.append(vis.vector(ptext[line].boundingBox()[1],ptext[line].boundingBox()[2],0))

    shape.width = width
    shape.widths = widths
    shape.start = start
    shape.starts = starts
    shape.descent = descent
    shape.vertical_spacing = vertical_spacing
    shape.upper_left = upper_left
    shape.upper_right = upper_right
    shape.lower_left = lower_left
    shape.lower_right = lower_right
    shape.align = align
    shape.height = height
    
    return shape

def psi_to_theta(psi):
	theta = atan(
	                  (sin(psi) - psi*cos(psi)) /
	                  (cos(psi) + psi*sin(psi))
	                 )
	return theta

def dotooth(N, res, phi, r, a, d, rf, verbose=0):

	rb = r * cos(phi)                # base circle radius
	ra = r + a                            # addendum circle radius
	rd = r - d                            # dedendum circle radius
	theta1 = pi / 2 / N              #    ref. docs
	psi2 = sqrt((r/rb)*(r/rb) - 1)   #    ref. docs
	theta2 = psi_to_theta(psi2) + theta1  #    ref. docs
	psi3 = sqrt((ra/rb)*(ra/rb) - 1) #    ref. docs
	theta3 = theta2 - psi_to_theta(psi3)  #    ref. docs
	theta4 = pi / N                  #    ref. docs

	# Print out some info, if verbose is selected
	if verbose == 1:
		print("\nGear Info:")
		print("N      = %s" % N)
		print("res    = %s" % res)
		print("phi    = %s" % phi)
		print("r      = %s" % r)
		print("a      = %s" % a)
		print("d      = %s" % d)
		print("rf     = %s" % rf)
		print("rb     = %s" % rb)
		print("ra     = %s" % ra)
		print("rd     = %s" % rd)
		print("theta1 = %s" % theta1)
		print("psi2   = %s" % psi2)
		print("theta2 = %s" % theta2)
		print("psi3   = %s" % psi3)
		print("theta3 = %s" % theta3)
		print("theta4 = %s" % theta4)
	tooth = []

	# Generate the +y-axis part of the bottom land
	i = 1
	numverts = 2 * res
	while i <= numverts:
		radius = rd -rf
		theta = i * (theta4-theta2) / numverts + theta2
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, y))
		i = i + 1

	# Generate the +y-axis bottom land fillet
	i = 0
	numverts = res
	while i <= numverts:
		radius = rf
		theta  = i * (pi / 2) / numverts
		x = -radius * cos(theta) + rd 
		y =  radius * sin(theta)
		theta  = atan(y/x) - theta2 - rf/rb
		radius = sqrt(x*x + y*y)
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, -y))
		i = i + 1

	# Generate the +y-axis involute profile
	i = 0
	numverts = 3 * res
	while i <= numverts:
		curpsi = atan(i*1.0/numverts) / atan(1) * psi3
		radius = rb * sqrt(1 + curpsi*curpsi)
		theta  = psi_to_theta(curpsi) - theta2
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, -y))
		i = i + 1

	# Generate the top land
	i = 0
	numverts = (res-1)
	while i <= numverts:
		radius = ra
		theta = i * theta3 / (numverts+1)
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, y))
		i = i + 1
	i = 1
	while i <= numverts:
		radius = ra
		theta = i * theta3 / (numverts+1)
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, -y))
		i = i + 1

	# Generate the -y-axis involute profile
	i = 0
	numverts = 3 * res
	while i <= numverts:
		curpsi = (1.0-atan(i*1.0/numverts) / atan(1)) * psi3
		radius = rb * sqrt(1 + curpsi*curpsi)
		theta  = psi_to_theta(curpsi) - theta2
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, y))
		i = i + 1

	# Generate the +y-axis bottom land fillet
	i = 0
	numverts = res
	while i <= numverts:
		radius = rf
		theta  = pi / 2 - i * (pi / 2) / numverts
		x = -radius * cos(theta) + rd
		y =  radius * sin(theta)
		theta  = atan(y/x) - theta2 - rf/rb
		radius = sqrt(x*x + y*y)
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, y))
		i = i + 1

	# Generate the -y-axis part of the bottom land
	i = 1
	numverts = 2 * res
	while i < numverts:
		radius = rd -rf
		theta = i * (theta4-theta2) / numverts + theta2
		x = radius * cos(theta)
		y = radius * sin(theta)
		tooth.append((x, -y))
		i = i + 1
	ln = 1
	for i in range(len(tooth)-ln):
		p1 = tooth[i]
		p2 = tooth[i+1]
		if p1 == p2:
		       tooth.pop(i+1)
		       ln += 1
	return tooth

def gear(pos=(0,0), n=20, radius=8, phi=pi/8, addendum=0.4, dedendum=0.6,
         fradius=0.1, rotate=0, scale=1.0, roundness=0, invert=False,
         internal=False, res=1, verbose=0):
        tooth = dotooth(n, res, phi, radius, addendum, dedendum,
                        fradius, verbose=0)
        if internal:
                itooth = []
                for p in tooth:
                        px = p[0]
                        py = p[1]
                        driro = sqrt(px*px +py*py) - radius
                        ir = radius - driro
                        ro = radius + driro
                        ix = (ir/ro)*px
                        iy = (ir/ro)*py
                        itooth.append((ix,iy))

                tooth = itooth
        gear = []
        #gear.extend(tooth)
        for i in range(0, n):
            rotan = -i*2*pi/n
            rtooth = []
            for (x, y) in tooth:
                rx = x*cos(rotan) - y*sin(rotan) + pos[0]
                ry = x*sin(rotan) + y*cos(rotan) + pos[1]
                rtooth.append((rx,ry))
            gear.extend(rtooth)
        #gear.append(gear[0])
        pp =  Polygon(gear)
        if rotate != 0.0: pp.rotate(rotate)
        if scale != 1.0 : pp.scale(scale,scale)
        roundness = 0
        if roundness > 0:
             cp0 = pp.contour(0)
             cp0.append(cp0[0])
             cp0 = shapes.roundc(cp0, roundness=roundness, invert=invert)
             pp = Polygon(cp0)
        return pp
