import cvisual
from primitives import distant_light, local_light

# Code to provide special initialization for a display object, and overloaded
# properties.
class display( cvisual.display):
    def __init__( self, **keywords):
        cvisual.display.__init__(self)
        self.material = None
        keys = keywords.keys()
        keys.sort()
        haslights = False
        for kw in keys:
            if (kw == 'lights'):
                haslights = True
            self.__setattr__(kw, keywords[kw])
        self.ambient = 0.2
        if (not haslights):
            light0 = distant_light( direction=(0.22, 0.44, 0.88), color=0.8,
                    local=0, display=self)
            light1 = distant_light( direction=(-0.88, -0.22, -.44), color=0.3,
                    local=0, display=self)
        self.select()
    def select(self):
            cvisual.display.set_selected(self)
    range = property( cvisual.display._get_range, cvisual.display._set_range)

    def _get_lights(self):
        # TODO: List comprehension used for Python 2.3 compatibility; replace with
        #   generator comprehension
        return tuple([ o for o in self.objects if isinstance(o, cvisual.light) ])
    def _set_lights(self, n_lights):
        old_lights = self._get_lights()
        for lt in old_lights:
            lt.visible = False
            
        # TODO: This is awful; if it's needed it needs to check the type of n_lights[0]
        #if type(n_lights) is tuple: # compatibilty with old "scene.lights = (1,0,0)"
        #    n_lights = [n_lights]
        
        for lt in n_lights:
            if isinstance( lt, cvisual.light ):  #< TODO: should this be allowed?
                lt.display = self
                lt.visible = True
            else:
                distant_light( pos=cvisual.vector(lt).norm(), color=lt.mag, display=self )
    lights = property( _get_lights, _set_lights, None)
