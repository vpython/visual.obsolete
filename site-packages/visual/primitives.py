# Code to complete the various primitive types
# Users should never import this module directly.  All of the public types and
# functions will be explicitly imported by __init__.py

from __future__ import division
import cvisual

from cvisual import vector
import crayola
color = crayola
from math import pi
from numpy import *

NCHORDS = 20.0 # number of chords in one coil of a helix

# Scenegraph management:
#   Renderable objects which become visible need to be added
#     to the scene graph using EITHER
#       - display.add_renderable() if not in a frame, OR
#       - frame.add_renderable()
#   Renderable objects which become invisible need to be removed using
#     the corresponding remove_renderable function.
#   If the display or frame of a visible object changes, it needs to
#     be removed and added.
# The py_renderable class encapsulates this logic, as well as
#   a fair amount of construction and attribute access common to
#   all renderables.

class py_renderable(object):
    def __init__(self, **keywords):
        _other = keywords.get("_other")
        if _other:
            del keywords["_other"]
            super(py_renderable,self).__init__(_other)
            self.__dict__ = dict(_other.__dict__)
            self.__display = _other.display
            self.__frame = _other.frame
            self.__visible = _other.visible
        else:
            super(py_renderable,self).__init__()
            self.__display = cvisual.display.get_selected()
            self.__frame = None
            self.__visible = True

        if keywords.has_key('display'):
            self.__display = keywords['display']
            del keywords['display']
        if keywords.has_key('visible'):
            self.__visible = keywords['visible']
            del keywords['visible']
        if keywords.has_key('frame'):
            self.__frame = keywords['frame']
            del keywords['frame']

        if not _other: self.init_defaults(keywords)

        self.process_init_args_from_keyword_dictionary( keywords )
 
        if self.__frame:
            if self.__frame.display != self.__display:
                raise ValueError, "Cannot initialize an object with a frame on a different display."

        self.check_init_invariants()

        if self.__visible:
            if self.__frame:
                self.__frame.add_renderable(self)
            elif self.__display:
                self.__display.add_renderable(self)

    def __copy__( self, **keywords):
        return self.__class__(_other=self, **keywords)

    def check_init_invariants(self):
        pass

    def set_display(self, display):
        "For internal use only. The setter for the display property."
        if display != self.__display:
        # Check that we aren't screwing up a frame.
            if self.__frame:
                raise ValueError, """Cannot change displays when within a
                    frame.  Make frame None, first."""
            if self.__display:
                self.__display.remove_renderable(self)
            self.__display = display
            self.__display.add_renderable(self)

    def get_display(self):
        "For internal use only.  The getter for the display property."
        return self.__display

    display = property( get_display, set_display)

    def get_frame(self):
        "For internal use only.  The getter for the frame property."
        return self.__frame

   # Overridden by the frame class below to add extra checks.
    def set_frame(self, frame):
        "For internal use only.  The setter for the frame property."
        if frame != self.__frame:
            if frame.display != self.__display:
                raise ValueError, "Cannot set to a frame on a different display."
            if frame and self.__frame:
                # Simply moving from one frame to another.
                self.__frame.remove_renderable(self)
                frame.add_renderable(self)
            elif frame and not self.__frame:
                # Moving into a reference frame when otherwise not in one.
                if self.__display:
                    self.__display.remove_renderable(self)
                frame.add_renderable(self)
            elif not frame and self.__frame:
                # Removing from a reference frame.
                self.__frame.remove_renderable(self)
                if self.__display:
                    self.__display.add_renderable(self)
            self.__frame = frame
            
    frame = property( get_frame, set_frame)

    def get_visible(self):
        "For internal use only.  The getter for the visible property."
        return self.__visible

    def set_visible(self, visible):
        "For internal use only.  The setter for the visible property."
        if visible and not self.__visible:
            if self.__frame:
                self.__frame.add_renderable(self)
            elif self.__display:
                self.__display.add_renderable(self)
        if not visible and self.__visible:
            if self.__frame:
                self.__frame.remove_renderable(self)
            elif self.__display:
                self.__display.remove_renderable(self)
        self.__visible = visible

    visible = property( get_visible, set_visible)

    def init_defaults(self, keywords):
        self.color = self.display.foreground
        if isinstance(self, cvisual.light):
            self.color = (1,1,1)
        elif 'material' not in keywords:
            self.material = self.display.material

    def process_init_args_from_keyword_dictionary( self, keywords ):
        if 'axis' in keywords: #< Should be set before 'length'
            self.axis = keywords['axis']
            del keywords['axis']

        # Assign all other properties
        for key, value in keywords.iteritems():
            setattr(self, key, value)

class py_renderable_uniform (py_renderable):
    def check_init_invariants(self):
        if not self.display.uniform:
            raise RuntimeError, "Do not create " + self.__class__.__name__ + " with nonuniform axes."      

class py_renderable_arrayobject (py_renderable):
   # Array objects are likely to need special handling in various places

    def get_red( self):
        return self.color[:,0]
    def get_green(self):
        return self.color[:,1]
    def get_blue(self):
        return self.color[:,2]
    def get_x(self):
        return self.pos[:,0]
    def get_y(self):
        return self.pos[:,1]
    def get_z(self):
        return self.pos[:,2]

    # Also none of them support opacity yet.   
    def set_opacity(self, opacity):
        raise RuntimeError, "Cannot yet specify opacity for curve, faces, convex, or points."
    opacity = property( None, set_opacity, None)

################################################################################
# Complete each type.

class distant_light (py_renderable, cvisual.distant_light):
    def set_pos(self, _): raise AttributeError("Attempt to set pos of a distant_light object.")
    pos = property(None,set_pos)

class local_light (py_renderable, cvisual.local_light):
    def set_direction(self, _): raise AttributeError("Attempt to set direction of a local_light object.")
    direction = property(None,set_direction)

class arrow (py_renderable_uniform, cvisual.arrow):
    pass

class cone (py_renderable_uniform, cvisual.cone):
    pass

class cylinder (py_renderable_uniform, cvisual.cylinder):
    pass

class sphere (py_renderable_uniform, cvisual.sphere):
    pass

class ring (py_renderable_uniform, cvisual.ring):
    pass

class box (py_renderable_uniform, cvisual.box):
    pass

class ellipsoid (py_renderable_uniform, cvisual.ellipsoid):
    pass

class pyramid (py_renderable_uniform, cvisual.pyramid ):
    pass

class label (py_renderable, cvisual.label):
    def init_defaults( self, keywords ):
        if not keywords.has_key('linecolor'):
            self.linecolor = self.display.foreground
        super(label, self).init_defaults( keywords )

class frame (py_renderable_uniform, cvisual.frame):
    def set_frame(self, frame):
        #Check to ensure that we are not establishing a cycle of reference frames.
        frame_iterator = frame
        while frame_iterator:
            if frame_iterator.frame is self:
                raise ValueError, "Attempted to create a cycle of reference frames."
            frame_iterator = frame_iterator.frame
        py_renderable_uniform.set_frame( self, frame)

class curve ( py_renderable_arrayobject, cvisual.curve ):
    pos = property( cvisual.curve.get_pos, cvisual.curve.set_pos, None)
    color = property( cvisual.curve.get_color, cvisual.curve.set_color, None)
    x = property( py_renderable_arrayobject.get_x, cvisual.curve.set_x, None)
    y = property( py_renderable_arrayobject.get_y, cvisual.curve.set_y, None)
    z = property( py_renderable_arrayobject.get_z, cvisual.curve.set_z, None)
    red = property( py_renderable_arrayobject.get_red, cvisual.curve.set_red, None)
    green = property( py_renderable_arrayobject.get_green, cvisual.curve.set_green, None)
    blue = property( py_renderable_arrayobject.get_blue, cvisual.curve.set_blue, None)

class points ( py_renderable_arrayobject, cvisual.points ):
    pos = property( cvisual.points.get_pos, cvisual.points.set_pos, None)
    color = property( cvisual.points.get_color, cvisual.points.set_color, None)
    x = property( py_renderable_arrayobject.get_x, cvisual.points.set_x, None)
    y = property( py_renderable_arrayobject.get_y, cvisual.points.set_y, None)
    z = property( py_renderable_arrayobject.get_z, cvisual.points.set_z, None)
    red = property( py_renderable_arrayobject.get_red, cvisual.points.set_red, None)
    green = property( py_renderable_arrayobject.get_green, cvisual.points.set_green, None)
    blue = property( py_renderable_arrayobject.get_blue, cvisual.points.set_blue, None)

class convex( py_renderable_arrayobject, py_renderable_uniform, cvisual.convex ):
    pos = property( cvisual.convex.get_pos, cvisual.convex.set_pos, None)

class faces( py_renderable_arrayobject, cvisual.faces ):
    pos = property( cvisual.faces.get_pos, cvisual.faces.set_pos, None)
    normal = property( cvisual.faces.get_normal, cvisual.faces.set_normal, None)
    color = property( cvisual.faces.get_color, cvisual.faces.set_color, None)
    red = property( py_renderable_arrayobject.get_red, cvisual.faces.set_red, None)
    green = property( py_renderable_arrayobject.get_green, cvisual.faces.set_green, None)
    blue = property( py_renderable_arrayobject.get_blue, cvisual.faces.set_blue, None)

class helix(py_renderable):
    def __init__( self, _other=None, pos=vector(),
        x=None, y=None, z=None, red=None, green=None, blue=None,
        axis=vector(1,0,0), radius=1.0, length=None, up=vector(0,1,0),
        coils=5, thickness=None, color=color.white, visible=True, **keywords):
        if keywords.has_key('display'):
            disp = keywords['display']
            del keywords['display']
        else:
            disp = cvisual.display.get_selected()
        if (not disp.uniform):
           raise RuntimeError, "Do not create helix with nonuniform axes."
        if keywords.has_key('frame'):
            fr = keywords['frame']
            del keywords['frame']
        else:
            fr = None
        self.process_init_args_from_keyword_dictionary( keywords )
        if x is not None:
            pos[0] = x
        if y is not None:
            pos[1] = y
        if z is not None:
            pos[2] = z
        if red is not None:
            color[0] = red
        if green is not None:
            color[1] = green
        if blue is not None:
            color[2] = blue
        self.__color = color
        axis = vector(axis)
        if length is None:
            length = axis.mag
        self.__length = length
        self.__axis = axis
        self.__radius = radius
        self.__up = up
        self.__coils = coils
        self.__thickness = radius/20.
        if thickness:
            self.__thickness = thickness
        self.__frame = frame(display=disp, frame=fr, pos=pos, axis=axis.norm(), up=up)
        self.helix = curve( frame = self.__frame, radius = self.__thickness/2.,
            color = color)
        self.create_pos()
      
    def create_pos(self):
        k = self.coils*(2*pi/self.__length)
        dx = (self.length/self.coils)/NCHORDS
        x_col = arange(0, self.__length+dx, dx)
        pos_data = zeros((len(x_col),3), float64)
        pos_data[:,0] = arange(0, self.__length+dx, dx)
        pos_data[:,1] = (self.radius) * sin(k*pos_data[:,0])
        pos_data[:,2] = (self.radius) * cos(k*pos_data[:,0])
        self.helix.pos = pos_data

    def set_pos(self, pos):
        self.__frame.pos = vector(pos)
    def get_pos(self):
        return self.__frame.pos

    def set_x(self, x):
        self.__frame.pos.x = x
    def get_x(self):
        return self.__frame.pos.x

    def set_y(self, y):
        self.__frame.pos.y = y
    def get_y(self):
        return self.__frame.pos.y

    def set_z(self, z):
        self.__frame.pos.z = z
    def get_z(self):
        return self.__frame.pos.z

    def set_color(self, color):
        self.__color = self.helix.color = color
    def get_color(self):
        return self.__color

    def set_red(self, red):
        self.helix.red = red
    def get_red(self):
        return self.helix.red

    def set_green(self, green):
        self.helix.green = green
    def get_green(self):
        return self.helix.green

    def set_blue(self, blue):
        self.helix.blue = blue
    def get_blue(self):
        return self.helix.blue

    def set_radius(self, radius):
        scale = radius/self.__radius
        self.__radius = radius
        self.helix.y *= scale
        self.helix.z *= scale
    def get_radius(self):
        return self.__radius

    def set_axis(self, axis):
        axis = vector(axis)
        self.__axis = axis
        self.__frame.axis = axis.norm()
        self.set_length(axis.mag)
    def get_axis(self):
        return self.__axis

    def set_length(self, length):
        self.helix.x *= (length/self.__length)
        self.__length = length
        self.__frame.axis = self.__axis.norm()
        self.__axis = length*self.__frame.axis
    def get_length(self):
        return self.__length

    def set_coils(self, coils):
        if self.__coils == coils: return
        self.__coils = coils
        self.create_pos()
    def get_coils(self):
        return self.__coils

    def set_thickness(self, thickness):
        if self.__thickness == thickness: return
        self.__thickness = thickness
        self.helix.radius = thickness/2.
    def get_thickness(self):
        return self.__thickness

    def set_display(self, disp):
        self.helix.display = self.frame.display = disp
    def get_display(self):
        return self.helix.display

    def set_frame(self, fr):
        self.__frame.frame = fr
    def get_frame(self):
        return self.__frame.frame

    def set_up(self, up):
        self.__frame.up = up
    def get_up(self):
        return self.__frame.up

    def set_visible(self, visible):
        self.helix.visible = visible
    def get_visible(self):
        return self.helix.visible

    pos = property( get_pos, set_pos, None)
    x = property( get_x, set_x, None)
    y = property( get_y, set_y, None)
    z = property( get_z, set_z, None)
    color = property( get_color, set_color, None)
    red = property( get_red, set_red, None)
    green = property( get_green, set_green, None)
    blue = property( get_blue, set_blue, None)
    axis = property( get_axis, set_axis, None)
    radius = property( get_radius, set_radius, None)
    coils = property( get_coils, set_coils, None)
    thickness = property( get_thickness, set_thickness, None)
    length = property( get_length, set_length, None)
    display = property( get_display, set_display, None)
    frame = property( get_frame, set_frame, None)
    up = property( get_up, set_up, None)
    visible = property( get_visible, set_visible, None)

import os, sys, glob

## The following code, from here to the end of findSystemFonts, is from
## https://mail.enthought.com/pipermail/enthought-svn/2005-September/000724.html
## Authors: John Hunter <jdhunter at ace.bsd.uchicago.edu>
##          Paul Barrett <Barrett at STScI.Edu>

#  OS Font paths
MSFolders = \
    r'Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders'

MSFontDirectories   = [
    r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts',
    r'SOFTWARE\Microsoft\Windows\CurrentVersion\Fonts']

X11FontDirectories  = [
    # what seems to be the standard installation point
    "/usr/X11R6/lib/X11/fonts/TTF/",
    # documented as a good place to install new fonts...
    "/usr/share/fonts/",
    # common application, not really useful
    "/usr/lib/openoffice/share/fonts/truetype/",
    ]

OSXFontDirectories = [
    "/Library/Fonts/",
    "/Network/Library/Fonts/",
    "/System/Library/Fonts/"
]

home = os.environ.get('HOME')
if home is not None:
    # user fonts on OSX
    path = os.path.join(home, 'Library', 'Fonts')
    OSXFontDirectories.append(path)

def win32FontDirectory():
    """Return the user-specified font directory for Win32."""

    try:
        import _winreg
    except ImportError:
        return os.path.join(os.environ['WINDIR'], 'Fonts')
    else:
        user = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, MSFolders)
        try:
            return _winreg.QueryValueEx(user, 'Fonts')[0]
        finally:
            _winreg.CloseKey(user)
    return None

def win32InstalledFonts(directory=None, fontext='ttf'):

    """Search for fonts in the specified font directory, or use the
system directories if none given.  A list of TrueType fonts are
returned by default with AFM fonts as an option.
"""

    import _winreg
    if directory is None:
        directory = win32FontDirectory()

    key, items = None, {}
    for fontdir in MSFontDirectories:
        try:
            local = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, fontdir)
        except OSError:
            continue

        if not local:
            return glob.glob(os.path.join(directory, '*.'+fontext))
        try:
            for j in range(_winreg.QueryInfoKey(local)[1]):
                try:
                    key, direc, any = _winreg.EnumValue( local, j)
                    if not os.path.dirname(direc):
                        direc = os.path.join(directory, direc)
                    direc = os.path.abspath(direc).lower()
                    if direc[-4:] == '.'+fontext:
                        items[direc] = 1
                except EnvironmentError:
                    continue
                except WindowsError:
                    continue

            return items.keys()
        finally:
            _winreg.CloseKey(local)
    return None

def OSXFontDirectory():
    """Return the system font directories for OS X."""

    fontpaths = []
    def add(arg,directory,files):
        fontpaths.append(directory)
    for fontdir in OSXFontDirectories:
        try:
            if os.path.isdir(fontdir):
                os.path.walk(fontdir, add, None)
        except (IOError, OSError, TypeError, ValueError):
            pass
    return fontpaths

def OSXInstalledFonts(directory=None, fontext=None):
    """Get list of font files on OS X - ignores font suffix by default"""
    if directory is None:
        directory = OSXFontDirectory()

    files = []
    for path in directory:
        if fontext is None:
            files.extend(glob.glob(os.path.join(path,'*')))
        else:
            files.extend(glob.glob(os.path.join(path, '*.'+fontext)))
            files.extend(glob.glob(os.path.join(path, '*.'+fontext.upper())))
    return files


def x11FontDirectory():
    """Return the system font directories for X11."""
    fontpaths = []
    def add(arg,directory,files):
        fontpaths.append(directory)

    for fontdir in X11FontDirectories:
        try:
            if os.path.isdir(fontdir):
                os.path.walk(fontdir, add, None)
        except (IOError, OSError, TypeError, ValueError):
            pass
    return fontpaths

def findSystemFonts(fontpaths=None, fontext='ttf'):

    """Search for fonts in the specified font paths, or use the system
paths if none given.  A list of TrueType fonts are returned by default
with AFM fonts as an option.
"""

    fontfiles = {}

    if fontpaths is None:

        if sys.platform == 'win32':
            fontdir = win32FontDirectory()

            fontpaths = [fontdir]
            # now get all installed fonts directly...
            for f in win32InstalledFonts(fontdir):
                base, ext = os.path.splitext(f)
                if len(ext)>1 and ext[1:].lower()==fontext:
                    fontfiles[f] = 1
        else:
            fontpaths = x11FontDirectory()
            # check for OS X & load its fonts if present
            if sys.platform == 'darwin':
                for f in OSXInstalledFonts(fontext=fontext):
                    fontfiles[f] = 1

    elif isinstance(fontpaths, (str, unicode)):
        fontpaths = [fontpaths]

    for path in fontpaths:
        files = glob.glob(os.path.join(path, '*.'+fontext))
        files.extend(glob.glob(os.path.join(path, '*.'+fontext.upper())))
        for fname in files:
            fontfiles[os.path.abspath(fname)] = 1

    return [fname for fname in fontfiles.keys() if os.path.exists(fname)]

def findFont(font):
    flist = findSystemFonts()
    if font == "serif":
        font = "Times New Roman"
    elif font == "sans-serif" or font == "sans":
        font = "Verdana"
    elif font == "monospace":
        font = "Courier New"
    font = font.lower()+".ttf"
    match = None
    sans = None
    freesans = freeserif = freemono = None
    for f in flist:
        if f[-4:] != ".ttf": continue
        if sys.platform == 'win32':
            name = f.split('\\')[-1].lower()
        else:
            name = f.split('/')[-1].lower()
        if name == font:
            match = f
            break
        elif name == "verdana.ttf":
            sans = f
        elif name == "freesans.ttf": # Ubuntu Linux
            freesans = f
        elif name == "freeserif.ttf": # Ubuntu Linux
            freeserif = f
        elif name == "freemono.ttf": # Ubuntu Linux
            freemono = f
        elif len(font) > len(name):
            if name[:-4] == font[:len(name)-4]:
                if match is None:
                    match = f
                elif len(match) < len(name):
                    match = f
        elif len(name) > len(font):
            if font[:-4] == name[:len(font)-4]:
                if match is None:
                    match = f
                elif len(match) < len(font):
                    match = f
    if freesans and not sans:
        sans = freesans
    if freesans and not match and font.lower()[:7] == "verdana":
        match = freesans
    elif freeserif and not match and font.lower()[:5] == "times":
        match = freeserif
    elif freemono and not match and font.lower()[:7] == "courier":
        match = freemono
    if match is not None:
        return match
    elif sans:
        return sans
    else:
        raise ValueError, 'Cannot find font "'+font+'"'

class text(object):

    def __init__(self, pos=(0,0,0), axis=(1,0,0), up=(0,1,0), height=1, color=color.white, 
                 x=None, y=None, z=None, red=None, green=None, blue=None,
                 text="", font="TIMES", align='left', visible=True,
                 depth=0.2, material=None, spacing=0.03, **keywords):
        if keywords.has_key('display'):
            self.__display = keywords['display']
            del keywords['display']
        else:
            self.__display = cvisual.display.get_selected()
        if (not self.display.uniform):
           raise RuntimeError, "Do not create 3D text with nonuniform axes."
        if keywords.has_key('frame'):
            fr = keywords['frame']
            del keywords['frame']
        else:
            fr = None

        if x is not None:
            pos[0] = x
        if y is not None:
            pos[1] = y
        if z is not None:
            pos[2] = z
        if red is not None:
            color[0] = red
        if green is not None:
            color[1] = green
        if blue is not None:
            color[2] = blue
        self.__color = color
        self.__material = material
        self.__visible = visible
        self.__up = up
        self.__font = font
        self.__text = text
        self.__height = float(height)
        self.__spacing = spacing
        try:
            if len(depth) == 3:
                self.__depth = vector(depth)
        except:
            self.__depth = vector(0,0,depth)
        self.__frame = frame(display=self.__display, frame=fr, pos=pos, axis=vector(axis).norm(), up=up)
        self.backframe = frame(frame=self.__frame)
        self.frontframe = frame(frame=self.__frame)
        self.check_align(align)
        self.createText()

    def fontlist(self):
        return findSystemFonts()

    def createText(self):
        self.getGlyphContour()
        self.paintText()

    def destroyText(self):
        self.back.visible = self.front.visible = self.sides.visible = False
        del self.back
        del self.front
        del self.sides
            
    def getGlyphContour(self):
        import Polygon
        from ttfquery import describe, glyphquery, glyph
        self.ptext = Polygon.Polygon()
        self.polies = []
        self.contours = []
        bb = 0
        font = describe.openFont(findFont(self.__font))
        try:
            desc = glyphquery.charDescent(font) # charDescent may not be present
            fontheight = glyphquery.charHeight(font)+desc
            self.fontscale = 1./fontheight
            self.__descent = self.fontscale*desc
        except:
            self.__descent = -0.3*self.__height # approximate value
            fontheight = 0.7*glyphquery.charHeight(font)
            self.fontscale = 1.3/glyphquery.charHeight(font)
        for newchar in self.__text:
            if newchar == " ":
                try:
                    if a:
                        bx = a.boundingBox()
                        bba = bx[1]-bx[0]
                        bba = min(bba, 700)
                        bb += bba
                except:
                    pass
                continue
            n = glyphquery.glyphName(font, newchar)
            g = glyph.Glyph(n)
            c = g.calculateContours(font)
            self.contours = []

            for contour in c:
                self.contours.append(glyph.decomposeOutline(contour))

            for contour in self.contours:
                pp = 0
                for i in range(len(contour)-1):
                    if (contour[i][0] == contour[i+1][0]) and (contour[i][1] == contour[i+1][1]):
                        contour.pop(i)
                        pp += 1
                        if i+pp >= len(contour)-1: break
                        
            a = Polygon.Polygon(self.contours[0])
            for i in range(1,len(self.contours)):
                b = Polygon.Polygon(self.contours[i])
                if a.covers(b): a = a - b
                else: a = a + b

            for contour in self.contours:
                self.polies.append(array(contour)++array([bb - a.boundingBox()[0],0]))

            a.shift(bb - a.boundingBox()[0] ,0)
           
            self.ptext += a
  
            bx = self.ptext.boundingBox()
            bb = bx[1] - bx[0] + self.__spacing*fontheight

        self.__upper_left = self.fontscale*self.__height*vector(self.ptext.boundingBox()[0],self.ptext.boundingBox()[3],0)
        self.__upper_right = self.fontscale*self.__height*vector(self.ptext.boundingBox()[1],self.ptext.boundingBox()[3],0)
        self.__lower_left = self.fontscale*self.__height*vector(self.ptext.boundingBox()[0],self.ptext.boundingBox()[2],0)
        self.__lower_right = self.fontscale*self.__height*vector(self.ptext.boundingBox()[1],self.ptext.boundingBox()[2],0)
            
        self.__width = (self.__lower_right-self.__upper_left).dot(vector(1,0,0))

    def alignText(self):
        if self.__align == 'left':
            self.backframe.pos = (0,0,0)
            self.frontframe.pos = self.__depth
        elif self.__align == 'right':
            self.backframe.pos = -vector(self.__width,0,0)
            self.frontframe.pos = self.__depth - vector(self.__width,0,0)
        elif self.__align == 'center':
            self.backframe.pos = -0.5*vector(self.__width,0,0)
            self.frontframe.pos = self.__depth - 0.5*vector(self.__width,0,0)
        # If extruding backward, move both back and front faces back, so front face is at specified pos
        if self.__depth.z < 0:
            self.backframe.pos += self.__depth
            self.frontframe.pos -= self.__depth

    def paintText(self):
       
        atri= self.ptext.triStrip()
        nvertices = 0
        for i in range(len(atri)):
            nvertices += 3*(len(atri[i])-2)
        vfront = zeros((nvertices, 2), float)
        vback = zeros((nvertices, 2), float)

        n = 0
        for i in range(len(atri)):
            for j in range(len(atri[i])-2):
                if j%2:
                    vfront[n:n+3] = (atri[i][j], atri[i][j+2], atri[i][j+1])
                    vback[n:n+3] = atri[i][j:j+3]
                else:
                    vback[n:n+3] = (atri[i][j], atri[i][j+2], atri[i][j+1])
                    vfront[n:n+3] = atri[i][j:j+3]
                n += 3
                
        self.alignText()
        
        scale = self.fontscale*self.__height

        vnormals = zeros((nvertices, 3), float)
        vnormals[...,2] = 1.0
        
        self.back = faces(frame=self.backframe, pos=scale*vback, normal=-vnormals,
                          color=self.__color, material=self.__material, visible=self.__visible)
        self.front = faces(frame=self.frontframe, pos=scale*vfront, normal=vnormals, 
                           color=self.__color, material=self.__material, visible=self.__visible)
        
        nvertices = 0
        for i in range(len(self.polies)):
            nvertices += 6*len(self.polies[i])
        vsides = zeros((nvertices, 3), float)
        vnormals = zeros((nvertices, 3), float)

        n = 0
        if self.__depth.z < 0: # adjust for case of backward extrusion
            shift = -self.__depth
        else:
            shift = self.__depth
            
        for i in range(len(self.polies)):
            polyi = self.polies[i]
            nstart = n
            for j in range(len(polyi)-1):
                v1 = scale*vector(polyi[j])
                v2 = scale*vector(polyi[j])+shift
                v3 = scale*vector(polyi[j+1])
                v4 = scale*vector(polyi[j+1])+shift
                if (v3-v1).mag == 0.: continue
                vsides[n:n+6] = (v1, v2, v3, v3, v2, v4)
                
                ## Create smooth normals on the sides
                newnormal = (vector(polyi[j])-vector(polyi[j+1])).cross(self.__depth).norm()
                if j > 0 and newnormal.dot(oldnormal) > 0.8:
                    vnormals[n-4] = vnormals[n-3] = vnormals[n-1] = vnormals[n:n+6] = (0.5*(oldnormal+newnormal)).norm()
                else:
                    vnormals[n:n+6] = newnormal
                oldnormal = newnormal
                n += 6
            # Check to see whether we came around to the original location
            if (vector(polyi[-1])-vector(polyi[0])).mag == 0. and newnormal.dot(vnormals[nstart]) > 0.8:
                vnormals[n-4] = vnormals[n-3] = vnormals[n-1] = vnormals[nstart:nstart+2] = \
                                vnormals[nstart+4] = vector(0.5*(vnormals[nstart]+newnormal)).norm()

        self.sides = faces(frame=self.backframe, pos=vsides, normal=vnormals,
                           color=self.__color, material=self.__material, visible=self.__visible)                       

    def rotate(self, angle=0, axis=None, origin=None):
        if axis is None:
            axis = self.__display.up
        if origin is None:
            origin = self.__frame.pos
        self.__frame.rotate(origin=vector(origin), angle=angle, axis=vector(axis))
                
    def set_text(self, text):
        if self.__text == text: return
        self.destroyText()
        self.__text = text
        self.createText()
    def get_text(self):
        return self.__text
                
    def check_align(self, align):
        if align == 'left' or align == 'right' or align == 'center':
            self.__align = align
        else:
            raise ValueError, "align must be 'left', 'right', or 'center'" 
                
    def set_align(self, align):
        self.check_align(align)
        self.alignText() 
    def get_align(self):
        return self.__align
                
    def set_font(self, font):
        if self.__font == font: return
        self.destroyText()
        self.__font = font
        self.createText()
    def get_font(self):
        return self.__font

    def set_height(self, height):
        height = float(height)
        if height == self.height: return
        oldheight = self.__height
        self.__height = height
        self.back.pos *= height/oldheight
        self.front.pos *= height/oldheight
        self.sides.pos *= height/oldheight
    def get_height(self):
        return self.__height
                
    def set_width(self, temp):
        raise AttributeError, "Cannot set the width"
    def get_width(self):
        return self.__width
                
    def set_descent(self, temp):
        raise AttributeError, "Cannot set the descent"
    def get_descent(self):
        return abs(self.__descent)
                
    def set_upper_left(self, temp):
        raise AttributeError, "Cannot set upper_left"
    def get_upper_left(self):
        if self.__align == 'left':
            vec = self.__upper_left
        elif self.__align == 'right':
            vec = self.__upper_left - vector(self.__width,0,0)
        elif self.__align == 'center':
            vec = self.__upper_left - 0.5*vector(self.__width,0,0)
        return self.__frame.frame_to_world(vec)
                
    def set_upper_right(self, temp):
        raise AttributeError, "Cannot set upper_right"
    def get_upper_right(self):
        if self.__align == 'left':
            vec = self.__upper_left + vector(self.__width,0,0)
        elif self.__align == 'right':
            vec = self.__upper_left
        elif self.__align == 'center':
            vec = self.__upper_left + 0.5*vector(self.__width,0,0)
        return self.__frame.frame_to_world(vec)
                
    def set_lower_left(self, temp):
        raise AttributeError, "Cannot set lower_left"
    def get_lower_left(self):
        if self.__align == 'left':
            vec = self.__lower_right - vector(self.__width,0,0)
        elif self.__align == 'right':
            vec = self.__lower_right - 2*vector(self.__width,0,0)
        elif self.__align == 'center':
            vec = self.__lower_right - 1.5*vector(self.__width,0,0)
        return self.__frame.frame_to_world(vec)
                
    def set_lower_right(self, temp):
        raise AttributeError, "Cannot set lower_right"
    def get_lower_right(self):
        if self.__align == 'left':
            vec = self.__lower_right
        elif self.__align == 'right':
            vec = self.__lower_right - vector(self.__width,0,0)
        elif self.__align == 'center':
            vec = self.__lower_right - 0.5*vector(self.__width,0,0)
        return self.__frame.frame_to_world(vec)

    def set_start(self, temp):
        raise AttributeError, "Cannot set start"
    def get_start(self):
        if self.__align == 'left':
            vec = vector(0,0,0)
        elif self.__align == 'right':
            vec = -vector(self.width,0,0)
        elif self.__align == 'center':
            vec = -0.5*vector(self.width,0,0)
        return self.__frame.frame_to_world(vec)

    def set_spacing(self, spacing):
        self.__spacing = spacing
    def get_spacing(self):
        return self.__spacing
                
    def set_pos(self, pos):
        self.__frame.pos = vector(pos)
    def get_pos(self):
        return self.__frame.pos

    def set_x(self, x):
        self.__frame.pos.x = x
    def get_x(self):
        return self.__frame.pos.x

    def set_y(self, y):
        self.__frame.pos.y = y
    def get_y(self):
        return self.__frame.pos.y

    def set_z(self, z):
        self.__frame.pos.z = z
    def get_z(self):
        return self.__frame.pos.z

    def set_material(self, material):
        self.front.material = self.back.material = self.sides.material = self.__material = material
    def get_material(self):
        return self.__material

    def set_color(self, color):
        self.front.color = self.back.color = self.sides.color = self.__color = color
    def get_color(self):
        return self.__color

    def set_red(self, red):
        self.__color = (red, self.__color[1], self.__color[2])
        self.front.color = self.back.color = self.sides.color = self.__color
    def get_red(self):
        return self.__color[0]

    def set_green(self, green):
        self.__color = (self.__color[0], green, self.__color[2])
        self.front.color = self.back.color = self.sides.color = self.__color
    def get_green(self):
        return self.__color[1]

    def set_blue(self, blue):
        self.__color = (self.__color[0], self.__color[1], blue)
        self.front.color = self.back.color = self.sides.color = self.__color
    def get_blue(self):
        return self.__color[2]

    def set_axis(self, axis):
        self.__frame.axis = vector(axis).norm()
    def get_axis(self):
        return self.__frame.axis.norm()

    def set_depth(self, depth):
        olddepth = self.__depth
        try:
            if len(depth) == 3:
                self.__depth = vector(depth)
        except:
            self.__depth = vector(0,0,depth)
        self.alignText()
        if olddepth.z < 0:
            olddepth = -olddepth
        shift = self.__depth
        if shift.z < 0:
            shift = -shift
        self.sides.pos[1::6] += shift - olddepth
        self.sides.pos[4::6] += shift - olddepth
        self.sides.pos[5::6] += shift - olddepth
    def get_depth(self):
        return self.__depth

    def set_display(self, disp):
        self.__display = self.__frame.display = disp
    def get_display(self):
        return self.__display

    def set_frame(self, fr):
        self.__frame = fr
    def get_frame(self):
        return self.__frame

    def set_up(self, up):
        self.__frame.up = up
    def get_up(self):
        return self.__frame.up

    def set_visible(self, visible):
        self.__frame.visible = self.__visible = visible
    def get_visible(self):
        return self.__visible

    pos = property( get_pos, set_pos, None)
    x = property( get_x, set_x, None)
    y = property( get_y, set_y, None)
    z = property( get_z, set_z, None)
    text = property( get_text, set_text, None)
    align = property( get_align, set_align, None)
    font = property( get_font, set_font, None)
    height = property( get_height, set_height, None)
    color = property( get_color, set_color, None)
    material = property( get_material, set_material, None)
    red = property( get_red, set_red, None)
    green = property( get_green, set_green, None)
    blue = property( get_blue, set_blue, None)
    axis = property( get_axis, set_axis, None)
    depth = property( get_depth, set_depth, None)
    display = property( get_display, set_display, None)
    frame = property( get_frame, set_frame, None)
    up = property( get_up, set_up, None)
    visible = property( get_visible, set_visible, None)
    width = property( get_width, set_width, None)
    descent = property( get_descent, set_descent, None)
    upper_left = property( get_upper_left, set_upper_left, None)
    upper_right = property( get_upper_right, set_upper_right, None)
    lower_left = property( get_lower_left, set_lower_left, None)
    lower_right = property( get_lower_right, set_lower_right, None)
    start = property( get_start, set_start, None)
    spacing = property( get_spacing, set_spacing, None)

