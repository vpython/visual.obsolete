# Code to complete the various primitive types
# Users should never import this module directly.  All of the public types and
# functions will be explicitly imported by __init__.py

import cvisual

from cvisual import vector
import crayola
color = crayola
from math import pi
from Numeric import *

# Scenegraph management:
# Internally, each display maintains three unordered lists of renderable
# objects.  The first is the set of all non-transparent objects in world space.
# The second is the set of all transparent objects in world space.  The
# transparent layer is depth-sorted and rendered from back to front each cycle.
# Objects in world space are added to a particular display by calling
# display.add_renderable( renderable).  The display will automatically determine
# if the object is translucent or not.  All objects are
# removed by calling display.remove_renderable( renderable).  The frame class
# also manages a list of renderable objects that lie within that reference
# frame.  The frame itself is a member of it's display's renderable set.  When
# a renderable object is within a frame, it should only be added to the frame's
# list with frame.add_renderable(renderable), and not to the set of objects in
# the parent display.
# The py_renderable class encapsulates this logic.

class py_renderable(object):
    """ This base class adds support for the visible, frame, and
    display attributes."""
    def __init__(self, keywords, _other=None):
        if _other:
            self.__display = keywords.get( 'display', _other.display)
            self.__frame = keywords.get( 'frame', _other.frame)
            self.__visible = keywords.get( 'visible', _other.visible)
        else:
            self.__display = keywords.get( 'display',
                cvisual.display.get_selected())
            self.__visible = keywords.get( 'visible', True)
            self.__frame = keywords.get('frame')
        if keywords.has_key('display'):
            del keywords['display']
        if keywords.has_key('visible'):
            del keywords['visible']
        if keywords.has_key('frame'):
            del keywords['frame']
        if self.__frame:
            if self.__frame.display != self.__display:
                raise ValueError, """Cannot initialize an object with a frame
                    on a different display."""
        

    def complete_init(self):
        "For internal use only.  This function completes two-stage "
        "initialization in VPython"
        if self.__visible:
            if self.__frame:
                self.__frame.add_renderable(self)
            elif self.__display:
                self.__display.add_renderable(self)

    def set_display(self, display):
        "For internal use only.  The setter for the display property."
        if display != self.__display:
            # Check that we aren't screwing up a frame.
            if self.__frame:
                raise ValueError, """Cannot change displays when within a
                    frame.  Make frame None, first."""
            if self.__display:
                self.__display.remove_renderable(self)
            self.__display.add_renderable(self)
            self.__display = display

    def get_display(self):
        "For internal use only.  The getter for the display property."
        return self.__display

    display = property( get_display, set_display)

    def get_frame(self):
        "For internal use only.  The getter for the frame property."
        return self.__frame

    # Overridden by the frame class below to add extra checks.
    def set_frame(self, frame):
        "For internal use only.  The setter for the frame property."
        if frame != self.__frame:
            if frame.display != self.__display:
                raise ValueError, "Cannot set to a frame on a different display."
            if frame and self.__frame:
                # Simply moving from one frame to another.
                self.__frame.remove_renderable(self)
                frame.add_renderable(self)
            elif frame and not self.__frame:
                # Moving into a reference frame when otherwise not in one.
                if self.__display:
                    self.__display.remove_renderable(self)
                frame.add_renderable(self)
            elif not frame and self.__frame:
                # Removing from a reference frame.
                self.__frame.remove_renderable(self)
                if self.__display:
                    self.__display.add_renderable(self)
            self.__frame = frame
                
    frame = property( get_frame, set_frame)

    def get_visible(self):
        "For internal use only.  The getter for the visible property."
        return self.__visible

    def set_visible(self, visible):
        "For internal use only.  The setter for the visible property."
        if visible and not self.__visible:
            if self.__frame:
                self.__frame.add_renderable(self)
            elif self.__display:
                self.__display.add_renderable(self)
        if not visible and self.__visible:
            if self.__frame:
                self.__frame.remove_renderable(self)
            elif self.__display:
                self.__display.remove_renderable(self)
        self.__visible = visible

    visible = property( get_visible, set_visible)
    

# The following generic algorithm will initialize any primitive in Visual.
# object is a reference to a Visual primitive object.
# keywords must be a dictionary of keyword:value pairs.
def process_init_args_from_keyword_dictionary( displayobject, keywords):
    """ The guts of a factory function that initializes the primitive 
    objects in Visual.  Client code should never call this function."""
    # Some objects (like the curve and convex) need to have color set before
    # pos if color is a single tuple.
    if keywords.has_key('color'):
        displayobject.color =  keywords['color']
        del keywords['color']
    else:
        displayobject.color = displayobject.display.foreground 
    # Add special handling for the faces object.
    # if displayobject.__class__ == faces:
    #    if keywords.has_key('pos'):
    #        displayobject.pos = keywords['pos']
    #        del keywords['pos']

    # Assign all other properties
    for key, value in keywords.iteritems():
        displayobject.__setattr__(key, value)

    # Complete the initialization of the object.
    displayobject.complete_init()

def copy_object( copy, other, keywords):
    # Copy the user-specified dict.
    copy.__dict__ = dict(other.__dict__)
    # Set the differing properties.
    for key, value in keywords.iteritems():
        copy.__setattr__(key, value)
    # Complete initialization and make this object visible.
    copy.complete_init()

################################################################################
# Complete each type.

class arrow (cvisual.arrow, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.arrow.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.arrow.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
       return arrow(_other=self, **keywords)


class cone (cvisual.cone, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.cone.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.cone.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return cone(_other=self, **keywords)


class cylinder (cvisual.cylinder, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.cylinder.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.cylinder.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return cylinder(_other=self, **keywords)


class sphere (cvisual.sphere, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.sphere.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.sphere.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
            self.shininess = 0.5
    def __copy__( self, **keywords):
        return sphere(_other=self, **keywords)


class ring (cvisual.ring, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.ring.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.ring.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return ring(_other=self, **keywords)


class box (cvisual.box, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.box.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            # In the case where both axis and length are set, this ensures that
            # length is set after axis.
            if keywords.has_key('axis'):
                self.axis = keywords['axis']
                del keywords['axis']
            copy_object( self, _other, keywords)
        else:
            cvisual.box.__init__(self)
            py_renderable.__init__(self, keywords)
            if keywords.has_key('axis'):
                self.axis = keywords['axis']
                del keywords['axis']
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return box(_other=self, **keywords)


class ellipsoid (cvisual.ellipsoid, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.ellipsoid.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.ellipsoid.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return ellipsoid(_other=self, **keywords)

class pyramid (cvisual.pyramid, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.pyramid.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.pyramid.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return pyramid(_other=self, **keywords)


class label (cvisual.label, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.label.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.label.__init__(self)
            py_renderable.__init__(self, keywords)
            if keywords.has_key('linecolor'):
                self.linecolor = keywords['linecolor']
                del keywords['linecolor']
            else:
                if keywords.has_key('display'):
                    self.linecolor = keywords['display'].foreground
                else:
                    self.linecolor = cvisual.display.get_selected().foreground
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return label(_other=self, **keywords)


class frame (cvisual.frame, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.frame.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.frame.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return frame(_other=self, **keywords)

    def set_frame(self, frame):
        #Check to ensure that we are not establishing a cycle of reference frames.
        frame_iterator = frame.frame
        while frame_iterator:
            if frame_iterator.frame == self:
                raise ValueError, "Attempted to create a cycle of reference frames."
            frame_iterator = frame_iterator.frame
        py_renderable.set_frame( self, frame)

class curve( cvisual.curve, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.curve.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.curve.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return curve(_other=self, **keywords)
    def get_red( self):
        return self.color[:,0]
    def get_green(self):
        return self.color[:,1]
    def get_blue(self):
        return self.color[:,2]
    def get_x(self):
        return self.pos[:,0]
    def get_y(self):
        return self.pos[:,1]
    def get_z(self):
        return self.pos[:,2]
    
    pos = property( cvisual.curve.get_pos, cvisual.curve.set_pos, None)
    color = property( cvisual.curve.get_color, cvisual.curve.set_color, None)
    x = property( get_x, cvisual.curve.set_x, None)
    y = property( get_y, cvisual.curve.set_y, None)
    z = property( get_z, cvisual.curve.set_z, None)
    red = property( get_red, cvisual.curve.set_red, None)
    green = property( get_green, cvisual.curve.set_green, None)
    blue = property( get_blue, cvisual.curve.set_blue, None)


class convex( cvisual.convex, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.convex.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.convex.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return convex(_other=self, **keywords)
    pos = property( cvisual.convex.get_pos, cvisual.convex.set_pos, None)


class faces( cvisual.faces, py_renderable):
    def __init__( self, _other=None, **keywords):
        if _other:
            cvisual.faces.__init__(self, _other)
            py_renderable.__init__(self, keywords, _other)
            copy_object( self, _other, keywords)
        else:
            cvisual.faces.__init__(self)
            py_renderable.__init__(self, keywords)
            process_init_args_from_keyword_dictionary(self, keywords)
    def __copy__( self, **keywords):
        return faces(_other=self, **keywords)
    pos = property( cvisual.faces.get_pos, cvisual.faces.set_pos, None)
    normal = property( cvisual.faces.get_normal, cvisual.faces.set_normal, None)
    color = property( cvisual.faces.get_color, cvisual.faces.set_color, None)

class helix(object):
    def __init__( self, _other=None, pos=vector(), axis=vector(1,0,0), radius=0.2, 
            coils=5, thickness=None, color=color.white):
        axis = vector(axis)
        self.frame = frame(pos=pos, axis=axis.norm())
        self.cached_length = axis.mag
        if thickness is None:
            thickness = radius/20.
        k = coils*(2*pi/self.cached_length)
        dx = (self.cached_length/coils)/12.
        pos_data = zeros((self.cached_length+dx,3), Float64)
        self.helix = curve( frame = self.frame, radius = thickness/2.,
            color = color)
        for x in arange( 0, self.length+dx, dx):
            self.helix.append( pos=vector( x, radius*sin(k*x), 
                radius*cos(k*x)))

    def set_pos(self, pos):
        self.frame.pos = vector(pos)

    def get_pos(self):
        return self.frame.pos

    def set_axis(self, axis):
        self.frame.axis = vector(axis)
        self.set_length(self.frame.axis.mag)

    def get_axis(self):
        return self.frame.axis

    def set_length(self, length):
        self.helix.pos[:,0] *= ( length/self.cached_length)
        self.cached_length = length

    def get_length(self):
        return self.cached_length

    def get_up(self):
        return self.frame.up

    def set_up(self, up):
        self.frame.up = up

    pos = property( get_pos, set_pos, None)
    axis = property( get_axis, set_axis, None)
    length = property( get_length, set_length, None)
    up = property( get_up, set_up, None)
