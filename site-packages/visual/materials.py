import cvisual
from numpy import array, reshape, fromstring, ubyte, ndarray
import os.path

class raw_texture(cvisual.texture):
    def __init__(self, **kwargs):
        cvisual.texture.__init__(self)
        for key, value in kwargs.iteritems():
            self.__setattr__(key, value)

class shader_material(cvisual.material):
    def __init__(self, **kwargs):
        cvisual.material.__init__(self)
        for key, value in kwargs.iteritems():
            self.__setattr__(key, value)

def loadBTX(name, shape):
    return reshape( fromstring( open(name,"rb").read(), ubyte ), shape )
def saveBTX(name, data):
    if hasattr(data, "getbands"):
        data = reshape( array( data.getdata(), ubyte ),
                        (data.size[0],data.size[1],len(data.getbands())) )

texturePath = os.path.split( __file__ )[0] + "/"
tx_turb3 = raw_texture( data=loadBTX( texturePath+"turbulence3.btx", (64,64,64,3) ),
                        interpolate=True, mipmap=False )
tx_wood = raw_texture( data=loadBTX( texturePath+"wood.btx", (512,512,3) ),
                       interpolate=True )

def texture( channels, data, mapping, data_type=None, mipmap=True, interpolate=True, name = "texture" ):
    channel_code = { ("luminance",) : "luminance",
                     ("opacity",) : "opacity",
                     ("luminance","opacity") : "luminance_opacity",
                     ("red","green","blue") : "rgb",
                     ("red","green","blue","opacity") : "rgbo"
                   }.get( tuple(channels), None )
    if not channel_code:
        raise ValueError( "Unsupported channel combination: " + repr(channels) )

    # For convenience, accept PIL images or similar protocol
    if hasattr(data, "getbands"):
        data = reshape( array( data.getdata(), ubyte ),
                        (data.size[0],data.size[1],len(data.getbands())) )

    if data_type is None:
        if not isinstance( data, ndarray ):
            raise TypeError("If data_type is not defined, data must be a numpy array.")
        if data.dtype.kind not in ("u","i","f"):
            raise TypeError("data_type not defined and data is of unknown type.")
    else:
        # TODO: restrict data_type?
        data = asarray( data, data_type )

    raw_tx = raw_texture( data = data,
                          type = channel_code,
                          mipmap = mipmap,
                          interpolate = interpolate )

    # TODO: Creating shaders here is inefficient if there are lots of textures.
    # What we want is multiple materials sharing one shader program, but that's not
    #   supported by the core at the moment.
    if mapping == "rectangular":
        return shader(
            name = name,
            textures = [ raw_tx ],
            translucent = "opacity" in channels,
            shader = """
                [fragment]
                uniform sampler2D tex0;
                
                void main(void) {
                    vec4 C = texture2D( tex0, mat_pos.xy*vec2(1,-1) );

                    gl_FragColor.rgb = lightAt( normalize(N), normalize(-v),
                                                C.rgb*gl_FrontMaterial.diffuse.rgb,
                                                vec3(0.,0.,0.),
                                                0. );
                    gl_FragColor.a = C.a * gl_Color.a;
                }""")
    elif mapping == "spherical":
        raw_tx.mipmap = False
        return shader(
            name = name,
            textures = [ raw_tx ],
            translucent = "opacity" in channels,
            shader = """
                [fragment]
                uniform sampler2D tex0;
                
                void main(void) {
                    vec2 tp = vec2( atan( mat_pos.x-0.5, mat_pos.z-0.5 ) * (0.5 / 3.14159) + 0.5,
                                    0.5 - atan( (mat_pos.y-0.5) / length( mat_pos.xz - 0.5 ) ) * (1.0 / 3.14159) );

                    vec4 C = texture2D( tex0, tp );

                    gl_FragColor.rgb = lightAt( normalize(N), normalize(-v),
                                                C.rgb*gl_FrontMaterial.diffuse.rgb,
                                                vec3(0.,0.,0.),
                                                0. );
                    gl_FragColor.a = C.a * gl_Color.a;
                }""")
    elif mapping == "sign":
        return shader(
            name = name,
            textures = [ raw_tx ],
            translucent = False,
            shader = """
                [vertex]
                varying float front_face;
                void main(void) {
                    basic();
                    if (gl_Normal.z > .001) front_face = 1.0;
                    else front_face = 0.0;
                }
                [fragment]
                varying float front_face;
                uniform sampler2D tex0;
                
                void main(void) {
                    vec4 C;
                    if ( front_face > 0.5 ) {
                        C = texture2D( tex0, mat_pos.xy*vec2(1,-1) );
                        // Texture is decaled over opaque color
                        C.rgb = mix( gl_Color.rgb, C.rgb, C.a );
                        C.a = gl_Color.a;
                    } else
                        C = gl_Color;

                    gl_FragColor.rgb = lightAt( normalize(N), normalize(-v),
                                                C.rgb,
                                                vec3(0.,0.,0.),
                                                0. );
                    gl_FragColor.a = C.a;
                }""")        
    else:
        raise ValueError( "Unknown mapping type: " + str(mapping) )

library = """
[vertex]
    #version 110
    varying vec3 N;
    varying vec3 v;
    varying vec3 p;
    uniform mat4 model_material;
    varying vec3 mat_pos;

    void basic(void)
    {
        p = vec3(gl_Vertex);
        v = vec3(gl_ModelViewMatrix * gl_Vertex);
        N = normalize(gl_NormalMatrix * gl_Normal);
        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
        gl_FrontColor = gl_Color;
        gl_BackColor = gl_Color;
        mat_pos = vec3( model_material * gl_Vertex );
    }

[fragment]
    #version 110
    varying vec3 N;
    varying vec3 v;
    varying vec3 p;
    varying vec3 mat_pos;
    uniform int light_count;

    vec3 lightAt( vec3 N, vec3 E, vec3 diffuse, vec3 specular, float shininess ) {
        vec3 color = gl_LightModel.ambient.rgb * diffuse;

        // All this ugliness is to deal with the need of Geforce 7xxx (and probably similar generation
        // ATI cards) to unroll loops at compile time.
        int count = light_count;
        if (count <= 2) {
            for(int i=0; i<2; i++) {
                if (i<count) {
                    vec3 L = normalize( gl_LightSource[i].position.xyz - v*gl_LightSource[i].position.w );
                    color += (gl_LightSource[i].diffuse.rgb * max(dot(N,L), 0.0))*diffuse;
                    if (shininess != 0.0) {
                        vec3 R = -reflect(L,N);
                        color += specular * gl_LightSource[i].specular.rgb * pow(max(dot(R,E),0.0),shininess);
                    }
                }
            }
        } else if (count <= 4) {
            for(int i=0; i<4; i++) {
                if (i<count) {
                    vec3 L = normalize( gl_LightSource[i].position.xyz - v*gl_LightSource[i].position.w );
                    color += (gl_LightSource[i].diffuse.rgb * max(dot(N,L), 0.0))*diffuse;
                    if (shininess != 0.0) {
                        vec3 R = -reflect(L,N);
                        color += specular * gl_LightSource[i].specular.rgb * pow(max(dot(R,E),0.0),shininess);
                    }
                }
            }
        } else {
            for(int i=0; i<8; i++) {
                if (i<count) {
                    vec3 L = normalize( gl_LightSource[i].position.xyz - v*gl_LightSource[i].position.w );
                    color += (gl_LightSource[i].diffuse.rgb * max(dot(N,L), 0.0))*diffuse;
                    if (shininess != 0.0) {
                        vec3 R = -reflect(L,N);
                        color += specular * gl_LightSource[i].specular.rgb * pow(max(dot(R,E),0.0),shininess);
                    }
                }
            }
        }
            
        return color;
    }
    
    vec3 light() {
        return lightAt( normalize(N), normalize(-v), gl_FrontMaterial.diffuse.rgb, vec3(.8,.8,.8), 64.0 );
    }
"""

def shader( name, shader, library = library, **kwargs ):
    if shader.find("[vertex]") < 0 and library:
        shader += """
            [vertex]
            void main() {
                basic();
            }"""
    shader = library + "\n".join( l.strip() for l in shader.split("\n") )
    return shader_material( name=name, shader=shader, **kwargs )

materials = [
    shader( name = "fast", library = "", shader = """
[vertex]
        void main() {
            gl_Position = ftransform();
            gl_FrontColor = gl_Color;
        }
[fragment]
        void main() {
            gl_FragColor = gl_Color;
        }"""),
    shader( name = "diffuse", shader = """
        [fragment]
        void main() {
            gl_FragColor.rgb = lightAt( N, normalize(-v), gl_FrontMaterial.diffuse.rgb, vec3(0,0,0), 0.0 );
            gl_FragColor.a = gl_Color.a;
        }"""),
    shader( name = "plastic", shader = """
        [fragment]
        void main() {
            gl_FragColor.rgb = light();
            gl_FragColor.a = gl_Color.a;
        }
        """),
    shader( name = "rough", textures = [ tx_turb3 ], shader = """
        [fragment]
        uniform sampler3D tex0;

        void main() {
            vec3 T = texture3D(tex0, mat_pos).rgb;
            T += texture3D(tex0, mat_pos * 8.).rgb/8.;
            vec3 N2 = N + T*.4;
            gl_FragColor.rgb = lightAt( normalize(N2), normalize(-v),
                                        gl_FrontMaterial.diffuse.rgb,
                                        vec3(.5,.5,.5),
                                        16. )
                                // xxx hack to reduce ambient
                                - gl_FrontMaterial.diffuse.rgb * gl_LightModel.ambient.rgb * .7;

            gl_FragColor.a = gl_Color.a;
        }
        """),
    shader( name = "wood", textures = [tx_wood, tx_turb3], shader = """
        [fragment]
        uniform sampler2D tex0;  // wood cross-section
        uniform sampler3D tex1;  // 3D turbulence

        void main() {
            vec3 tp = mat_pos.xyz * .5;
            vec3 T = texture3D(tex1, tp).rgb;
            T += texture3D(tex1, tp * 8.).rgb/8.;

            vec2 wt = mat_pos.xy*.85 + mat_pos.z*.1 + T.xy * .05;

            vec3 C = texture2D( tex0, wt ).rgb;

            gl_FragColor.rgb = lightAt( normalize(N), normalize(-v),
                                        C*gl_FrontMaterial.diffuse.rgb,
                                        vec3(.5,.5,.5),
                                        5. );
            gl_FragColor.a = gl_Color.a;
        }
        """),
    shader( name = "marble", textures=[tx_turb3], shader = """
        [fragment]
        uniform sampler3D tex0;

        void main() {
            vec3 tp = mat_pos;
            vec3 T = texture3D(tex0, tp).rgb;
            T += texture3D(tex0, tp * 8.).rgb/4.;

            float a = 0.5 + 0.5*sin( mat_pos.y*16. + T.x*10. );
            vec3 C = mix( vec3(.4,.3,.3), vec3(1.,1.,1.), a );
            vec3 N2 = N + T*1.;
            gl_FragColor.rgb = lightAt( normalize(N2), normalize(-v), C*gl_FrontMaterial.diffuse.rgb, vec3(.8,.8,.8), 100. );
            gl_FragColor.a = gl_Color.a;
        }
        """),
    # TODO: fancy earth renderer with atmosphere, gloss map, bump map
    texture( name = "earth",
        data = loadBTX( texturePath + "earth.btx", (1024,512,3) ),
        channels=("red","green","blue"),
        mapping = "spherical",
        interpolate = True ),
]

for mat in materials:
    globals()[mat.name] = mat
del mat
