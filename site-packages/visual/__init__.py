version = (4, "beta25")

# Copyright David Scherer and others, see license.txt

# Add the GTK runtime libs to PATH
import sys, time, os, os.path

true = 1
false = 0

# Import all of the public modules into the global namespace

# The following manipulations of math and numpy functions is a workaround
# for the problem that in going from Numeric to numpy, the return by numpy
# from e.g. sqrt is numpy.float64, not float, which is not recognized as
# matching float in the operator overloading machinery, including Boost.
# This means is that right multiplication scalar*vector is not caught
# and the result is returned as numpy.ndarray instead of vector, which
# can be a big performance hit in vector calculations.

# There is an advantage to this workaround: sqrt(scalar) is much faster
# this way than when using the numpy sqrt, and there is little penalty
# for the numpy sqrt(array).

from math import *
_m_ceil = ceil
_m_cos = cos
_m_cosh = cosh
_m_exp = exp
_m_fabs = fabs
_m_floor = floor
_m_fmod = fmod
_m_frexp = frexp
_m_hypot = hypot
_m_ldexp = ldexp
_m_log = log
_m_log10 = log10
_m_modf = modf
_m_sin = sin
_m_sinh = sinh
_m_sqrt = sqrt
_m_tan = tan
_m_tanh = tanh

from numpy import *
_n_ceil = ceil
_n_cos = cos
_n_cosh = cosh
_n_exp = exp
_n_fabs = fabs
_n_floor = floor
_n_fmod = fmod
_n_frexp = frexp
_n_hypot = hypot
_n_ldexp = ldexp
_n_log = log
_n_log10 = log10
_n_modf = modf
_n_sin = sin
_n_sinh = sinh
_n_sqrt = sqrt
_n_tan = tan
_n_tanh = tanh

def ceil(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_ceil(x)
    return _n_ceil(x)
def cos(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_cos(x)
    return _n_cos(x)
def cosh(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_cosh(x)
    return _n_cosh(x)
def exp(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_exp(x)
    return _n_exp(x)
def fabs(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_fabs(x)
    return _n_fabs(x)
def floor(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_floor(x)
    return _n_floor(x)
def fmod(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_fmod(x)
    return _n_fmod(x)
def frexp(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_frexp(x)
    return _n_frexp(x)
def hypot(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_hypot(x)
    return _n_hypot(x)
def ldexp(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_ldexp(x)
    return _n_ldexp(x)
def log(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_log(x)
    return _n_log(x)
def log10(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_log10(x)
    return _n_log10(x)
def modf(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_modf(x)
    return _n_modf(x)
def sin(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_sin(x)
    return _n_sin(x)
def sinh(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_sinh(x)
    return _n_sinh(x)
def sqrt(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_sqrt(x)
    return _n_sqrt(x)
def tan(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_tan(x)
    return _n_tan(x)
def tanh(x):
    t = type(x)
    if t is float or t is int or t is long: return _m_tanh(x)
    return _n_tanh(x)

import crayola
color = crayola
import cvisual
cvisual.init_numpy()
from cvisual import vector, mag, mag2, norm, cross, rotate, comp, proj
from cvisual import diff_angle, rate
from visual.primitives import arrow, cylinder, cone, sphere, box, ring, label
from visual.primitives import frame, pyramid, ellipsoid, curve, faces, convex, helix
from visual.primitives import texture, points
from visual.ui import display, light
from cvisual import vector_array, scalar_array


# Find the location of the glade file (normally site-packages/visual/)
import os, sys, os.path
for _dir in sys.path:
    if _dir is "":
        _dir = os.curdir
    if os.path.isdir(_dir):
        if "visual" in os.listdir(_dir):
            cvisual._set_dataroot( os.path.join(_dir, "visual") + os.path.sep)
            break
    
try: import threading    # because it messes with exitfunc, see below
except: pass

# The following ensures that __waitclose will be run
# when we reach the end of the program,
# to permit viewing and navigating the scene.
import atexit
atexit.register(cvisual.waitclose)

# The following tells idle_VPython to not close down until/unless
# the scene is closed down by the user. It is left here for
# compatibility with old versions of idle_VPython but will no longer
# needed with the new Idle distributed with Python 2.3.
sys.ready_to_exit = cvisual.allclosed

# Construct the default display object.
scene = display()

# Work around a strange character conversion bug specific to Linux.  
# On Linux+GTK,label.text is a Unicode string. However, the Python and GTK encodings
# of Unicode are not the same (GTK uses UTF-8, and Python uses either
# UCS-16 or UCS-32 of the host endianness). So, there is some code that
# performs an implicit conversion between a Glib::ustring (a GTK UTF-8
# string) and Python Unicode strings. For some reason, the very first
# conversion included some extra characters at the beginning of the string
# when converted back to Python. The following strange statements work around 
# the bug by making and throwing away the first round-trip conversion between the two systems.
__tmp = label( text="123", visible=False)
__tmp_txt = __tmp.text
del __tmp
del __tmp_txt
