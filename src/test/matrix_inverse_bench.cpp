#include "util/tmatrix.hpp"
#include "util/timer.hpp"
#include <math.h>

#include <iostream>
#include <numeric>
#include <boost/nondet_random.hpp>
#include <boost/random/uniform_real.hpp>

/* The purpose of this bench test is to determine which of two implementations
 * of a 4x4 matrix inverse are faster.  The first is a traditional loop-based
 * version that was taken directly from the Mesa 6.2.1 sources 
 * (src/glu/sgi/libutil/project.c).  The second was generated by symbolically
 * solving the inverse using GiNaC and displaying the results.  It is loopless
 * and does not make a temporary matrix.  The implementaion is impossible to
 * read, so I have also added checking code to ensure that the inverse*original
 * really does produce the identity matrix for each case.
 * 
 * Results: The GiNaC-generated code is 30-60% faster (depending on the CPU)
 * and 300% larger than the SGI code, but only when a large common subexpression
 * has been removed and GCC is run with full optimization.
 * 
 * With a numerical stability tolerance level of about 1e-14, both algorighms
 * display occasional stability issues with the GLU version fairing a little
 * worse on Crusoe. (other CPU's were not tested).
 * 
 * Conclusion: Use the unrolled version when code size is not a factor.
 */

using namespace cvisual;

/*
** Make m an identity matrix
*/
static void __gluMakeIdentityd(GLdouble m[16])
{
    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
}

static void __gluMultMatricesd(const GLdouble a[16], const GLdouble b[16],
             GLdouble r[16])
{
    int i, j;

    for (i = 0; i < 4; i++) {
 for (j = 0; j < 4; j++) {
      r[i*4+j] = 
        a[i*4+0]*b[0*4+j] +
        a[i*4+1]*b[1*4+j] +
        a[i*4+2]*b[2*4+j] +
        a[i*4+3]*b[3*4+j];
 }
    }
}

/*
** inverse = invert(src)
*/
// Optimized: 574 bytes, 7-8 usec
// Unoptimized: 882 bytes, 10 usec
static int __gluInvertMatrixd(const GLdouble src[16], GLdouble inverse[16])
{
    int i, j, k, swap;
    double t;
    GLdouble temp[4][4];

    for (i=0; i<4; i++) {
  for (j=0; j<4; j++) {
      temp[i][j] = src[i*4+j];
   }
    }
    __gluMakeIdentityd(inverse);

    for (i = 0; i < 4; i++) {
    /*
 ** Look for largest element in column
  */
 swap = i;
  for (j = i + 1; j < 4; j++) {
      if (fabs(temp[j][i]) > fabs(temp[i][i])) {
     swap = j;
      }
  }

 if (swap != i) {
       /*
     ** Swap rows.
      */
     for (k = 0; k < 4; k++) {
      t = temp[i][k];
        temp[i][k] = temp[swap][k];
        temp[swap][k] = t;

        t = inverse[i*4+k];
        inverse[i*4+k] = inverse[swap*4+k];
        inverse[swap*4+k] = t;
     }
  }

 if (temp[i][i] == 0) {
     /*
     ** No non-zero pivot.  The matrix is singular, which shouldn't
     ** happen.  This means the user gave us a bad matrix.
      */
     return GL_FALSE;
   }

 t = temp[i][i];
    for (k = 0; k < 4; k++) {
      temp[i][k] /= t;
       inverse[i*4+k] /= t;
   }
  for (j = 0; j < 4; j++) {
      if (j != i) {
      t = temp[j][i];
        for (k = 0; k < 4; k++) {
          temp[j][k] -= temp[i][k]*t;
            inverse[j*4+k] -= inverse[i*4+k]*t;
        }
      }
  }
    }
    return GL_TRUE;
}

// A fully unrolled 4x4 matrix inverse 
// (GCC 3.3, 800 MHz Crusoe processor)
// Unoptimized: 14479 bytes, 25 usec
// Optimized: 1843 bytes, 4 usec
static void inverse( tmatrix& dest, const tmatrix& src)
{
    // Pull out this common subexpression for GCC's aid.  This improves
    // performance dramaticly.
    double common = 1.0/(src(0,2)*src(3,0)*src(2,3)*src(1,1)-src(0,2)*src(3,0)
        *src(1,3)*src(2,1)+src(0,2)*src(1,0)*src(3,3)*src(2,1)+src(0,3)*src(3,1)
        *src(2,2)*src(1,0)+src(0,3)*src(1,1)*src(3,2)*src(2,0)+src(0,0)*src(2,2)
        *src(1,1)*src(3,3)-src(1,3)*src(0,1)*src(3,2)*src(2,0)+src(0,3)*src(3,0)
        *src(1,2)*src(2,1)+src(0,1)*src(2,3)*src(1,0)*src(3,2)-src(1,2)*src(0,0)
        *src(3,3)*src(2,1)-src(0,3)*src(3,0)*src(2,2)*src(1,1)-src(3,0)*src(1,2)
        *src(0,1)*src(2,3)-src(0,2)*src(3,1)*src(2,3)*src(1,0)-src(3,1)*src(1,3)
        *src(0,0)*src(2,2)-src(0,3)*src(3,1)*src(1,2)*src(2,0)-src(0,2)*src(1,1)
        *src(3,3)*src(2,0)-src(0,3)*src(1,0)*src(3,2)*src(2,1)+src(0,2)*src(3,1)
        *src(1,3)*src(2,0)+src(3,1)*src(1,2)*src(0,0)*src(2,3)-src(0,0)*src(2,3)
        *src(1,1)*src(3,2)+src(1,2)*src(0,1)*src(3,3)*src(2,0)+src(3,0)*src(1,3)
        *src(0,1)*src(2,2)-src(0,1)*src(2,2)*src(1,0)*src(3,3)+src(1,3)*src(0,0)
        *src(3,2)*src(2,1));
        
    dest(0,0) = common*(-src(1,2)*(src(3,3)*src(2,1)-src(3,1)*src(2,3))-src(2,3)*src(1,1)*src(3,2)+src(1,3)*src(3,2)*src(2,1)-src(2,2)*(src(3,1)*src(1,3)-src(1,1)*src(3,3)));
    dest(0,1) = common*(src(0,2)*(src(3,3)*src(2,1)-src(3,1)*src(2,3))+src(0,3)*(src(3,1)*src(2,2)-src(3,2)*src(2,1))+(src(2,3)*src(3,2)-src(2,2)*src(3,3))*src(0,1));
    dest(0,2) = common*(src(0,3)*(src(1,1)*src(3,2)-src(3,1)*src(1,2))+src(1,2)*src(0,1)*src(3,3)-src(1,3)*src(0,1)*src(3,2)+src(0,2)*(src(3,1)*src(1,3)-src(1,1)*src(3,3)));
    dest(0,3) = common*(-src(1,2)*src(0,1)*src(2,3)-(src(0,2)*src(2,1)-src(0,1)*src(2,2))*src(1,3)-src(0,3)*(src(2,2)*src(1,1)-src(1,2)*src(2,1))+src(0,2)*src(2,3)*src(1,1));
    dest(1,0) = common*(-src(1,3)*src(3,2)*src(2,0)+src(1,2)*(-src(3,0)*src(2,3)+src(3,3)*src(2,0))+src(2,3)*src(1,0)*src(3,2)+(src(3,0)*src(1,3)-src(1,0)*src(3,3))*src(2,2));
    dest(1,1) = common*(-src(0,2)*(-src(3,0)*src(2,3)+src(3,3)*src(2,0))-(src(2,3)*src(3,2)-src(2,2)*src(3,3))*src(0,0)-src(0,3)*(-src(3,2)*src(2,0)+src(3,0)*src(2,2)));
    dest(1,2) = common*(-src(0,3)*(src(1,0)*src(3,2)-src(3,0)*src(1,2))+src(1,3)*src(0,0)*src(3,2)-src(0,2)*(src(3,0)*src(1,3)-src(1,0)*src(3,3))-src(1,2)*src(0,0)*src(3,3));
    dest(1,3) = common*(-src(1,3)*src(0,0)*src(2,2)+src(1,2)*src(0,0)*src(2,3)+(src(2,2)*src(1,0)-src(1,2)*src(2,0))*src(0,3)+src(0,2)*(src(1,3)*src(2,0)-src(2,3)*src(1,0)));
    dest(2,0) = common*((src(1,0)*src(2,1)-src(1,1)*src(2,0))*src(3,3)+src(3,0)*(src(2,3)*src(1,1)-src(1,3)*src(2,1))+src(3,1)*(src(1,3)*src(2,0)-src(2,3)*src(1,0)));
    dest(2,1) = common*(src(3,1)*src(0,0)*src(2,3)-src(0,0)*src(3,3)*src(2,1)-src(0,3)*src(3,1)*src(2,0)-src(3,0)*src(0,1)*src(2,3)+src(0,3)*src(3,0)*src(2,1)+src(0,1)*src(3,3)*src(2,0));
    dest(2,2) = common*(-src(0,3)*src(3,0)*src(1,1)-src(0,1)*src(1,0)*src(3,3)+src(3,0)*src(1,3)*src(0,1)-src(3,1)*src(1,3)*src(0,0)+src(0,3)*src(3,1)*src(1,0)+src(0,0)*src(1,1)*src(3,3));
    dest(2,3) = common*(src(0,1)*src(2,3)*src(1,0)+src(0,3)*src(1,1)*src(2,0)-src(0,3)*src(1,0)*src(2,1)+src(1,3)*src(0,0)*src(2,1)-src(0,0)*src(2,3)*src(1,1)-src(1,3)*src(0,1)*src(2,0));
    dest(3,0) = common*(src(1,1)*src(3,2)*src(2,0)+src(3,1)*src(2,2)*src(1,0)+src(3,0)*src(1,2)*src(2,1)-src(3,1)*src(1,2)*src(2,0)-src(3,0)*src(2,2)*src(1,1)-src(1,0)*src(3,2)*src(2,1));
    dest(3,1) = common*(src(3,0)*src(0,1)*src(2,2)-src(0,1)*src(3,2)*src(2,0)-src(0,2)*src(3,0)*src(2,1)+src(0,0)*src(3,2)*src(2,1)-src(3,1)*src(0,0)*src(2,2)+src(0,2)*src(3,1)*src(2,0));
    dest(3,2) = common*(-src(0,0)*src(1,1)*src(3,2)-src(3,0)*src(1,2)*src(0,1)-src(0,2)*src(3,1)*src(1,0)+src(3,1)*src(1,2)*src(0,0)+src(0,2)*src(3,0)*src(1,1)+src(0,1)*src(1,0)*src(3,2));
    dest(3,3) = common*(src(0,0)*src(2,2)*src(1,1)-src(0,2)*src(1,1)*src(2,0)+src(1,2)*src(0,1)*src(2,0)+src(0,2)*src(1,0)*src(2,1)-src(1,2)*src(0,0)*src(2,1)-src(0,1)*src(2,2)*src(1,0));
    return;
}

int realmain( std::vector<std::string>&)
{
    std::cerr.precision( std::numeric_limits<double>::digits10);
    // A source of entropy that never runs dry.
    boost::random_device rng;  
    boost::uniform_real<> dist( -100.0, 100.0);
    
    size_t test_iterations = 50;
    timer times;
    while (test_iterations != 0) {
        tmatrix src;
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                src(i,j) = dist(rng);
        tmatrix dest;
        times.lap_start();
        ::inverse(dest, src);
        times.lap_stop();
        --test_iterations;
        
        tmatrix ident = src*dest;
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                if (i == j && fabs(1.0 - ident(i,j)) > 1e-14)
                    fprintf( stderr, "ident(%d,%d) is not unity by: %.7e\n", i, j, 1.0-ident(i,j));
                else if ( i != j && fabs(ident(i,j)) > 1e-14)
                    std::cerr << "ident(" << i << "," << j << ") is not zero: " << ident(i,j) << std::endl;
            }
        }
    }
    std::pair<double, double> interval = times.confidence_interval();
    std::cout << "4x4 matrix inverse speed 95% confidence interval:  (";
    std::cout << interval.first << " +/- " << interval.second << ")\n";
    std::cout << "\t std deviation: " << times.std_deviation() << "\n";
    times.reset();
    
    test_iterations = 50;
    while (test_iterations != 0) {
        double src[16];
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                src[i*4 + j] = dist(rng);
        double dest[16];
        times.lap_start();
        __gluInvertMatrixd(src, dest);
        times.lap_stop();
        test_iterations--;
        
        // Check the results
        double ident[16];
        __gluMultMatricesd(src, dest, ident);
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j) {
                if (i == j && fabs(1.0 - ident[i*4+j]) > 1e-14)
                    fprintf( stderr, "ident(%d,%d) is not unity by: %.7e\n", i, j, 1.0-ident[i*4+j]);
                    // std::cerr << "ident(" << i << "," << j << ") is not unity by: " << 1.0-ident[i*4+j] << std::endl;
                else if (i != j && fabs(ident[i*4+j]) >  1e-14)
                    std::cerr << "ident(" << i << "," << j << ") is not zero: " << ident[i*4+j] << std::endl;
            }
    }
    interval = times.confidence_interval();
    std::cout << "GLU matrix inverse speed 95% confidence interval:  (";
    std::cout << interval.first << " +/- " << interval.second << ")\n";
    std::cout << "\t std deviation: " << times.std_deviation() << "\n";

    return 0;
}

