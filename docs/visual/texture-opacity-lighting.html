<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>
<h2 align="center">Summary of new features in the VPython version 4 beta release </h2>
<p align="center"><a href="index.html">Back to contents</a></p>
<h3>Beta release</h3>
<p>This beta release is experimental in the sense that there are known bugs described 
  <a href="#bugs">below</a>. Feel free to play with the exciting new features, 
  but be aware that you may encounter problems.</p>
<p>There is a new example program texture_and_lighting.py that displays many of 
  the new features: a swinging light illuminates a translucent  ball 
  that rolls on a wood-texture table. Also see the
  example programs material_test.py, stonehenge.py, and boxlighttest.py.</p>
<h3>Transparency/opacity</h3>
<p>You can make most objects be  transparent by specifying a value from
   0-1 inclusive for the attribute &quot;opacity&quot;. For example, box(color=color.red,
    opacity=0.8) is slightly transparent. An opacity value of 0 means totally
   transparent, 
  and 1 means totally opaque. Currently curve, convex, faces, points, and helix objects
   do not allow transparency. </p>
<h3>Materials</h3>
<p>You can give a material property such as wood to an object: box(color=color.orange,
  material=materials.wood). Materials currently available include wood, plastic,
  marble, earth (continents and oceans), rough, diffuse, and unlit (that is,
  display the specified color unaffected by existing lights). The example program
  material_test.py shows examples of all of these materials.</p>
<p>Some materials such as wood are oriented to the specified axis. For example,
  a wood box with default axis = (1,0,0) shows tree rings on its yz surfaces
  and stripes on the other faces. Changing the axis changes which face you see
  the tree rings on. </p>
<p>Specifying a material has an effect only on computers with modern graphics capabilities such as NVIDIA or Radeon graphics cards. On  computers without such graphics capabilities, objects are displayed without material properties.</p>
<p>You can create a texture object and then apply it to the surface of an object. 
  A surface texture 
  is an M by N array of 1, 2, 3, or 4 numerical values (a list or tuple). M and 
  N must be powers of 2 (1, 2, 4, 8, 16, 32, etc.). The numerical values can represent red, green, blue, luminance (brightness), or opacity.</p>
<p>Here are the possible values 
  for each slot in the array:</p>
<p>1 value: channels must be [ &quot;luminance&quot;] (how bright) or
  [&quot;opacity&quot;]</p>
<p>2 values (luminance and opacity): channels must be [&quot;luminance&quot;,&quot;opacity&quot;]</p>
<p>3 values (red,green,blue): channels must be [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;] </p>
<p>4 values (red,green,blue,opacity): channels must be [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;opacity&quot;] </p>
<p>You can create a numeric array of zeros in various formats, then assign values:</p>
<p>zeros([...], ubyte) means an 8-bit unsigned integer 0-255<br>
  zeros([...], short) means a 16-bit integer plus or minus 0-32767<br>
  zeros([...], int) means a 32-bit integer plus or minus 0-2147483648<br>
  zeros([...], float) means a floating-point (fractional) number</p>
<p>Here is an example program in which a checkerboard texture is created and
  applied  to a box. (An &quot;array&quot; is a numerical array supported by the numpy
  module which is imported when you import &quot;visual&quot;.) </p>
<pre>from visual import *
checkerboard = array([[0,1,0,1], <br>		      [1,0,1,0],<br>		      [0,1,0,1],<br>		      [1,0,1,0]], float)<br>lum = materials.texture( data=checkerboard,<br>                         channels=[&quot;luminance&quot;],<br>                         mapping=&quot;rectangular&quot;,<br>                         interpolate=False)<br>box(axis=(0,0,1), color=color.cyan, material=lum)
</pre>
<p>If you wanted to create a texture containing &quot;rgb&quot; values, you could
   start with zeros([M,N,3], float), and entries into this array would be the
  usual 
  (red,green,blue) triples, with values for each color in the range 0-1 inclusive.</p>
<p>The example above uses a &quot;rectangular&quot; mapping, which places the texture on
  two opposing faces of a box. By default, one of the faces is in the (1,0,0)
  direction, but this can be changed by specifying a different axis for the box.
  Other texture mappings are &quot;spherical&quot; and &quot;sign&quot;, the latter being similar
  to &quot;rectangular&quot; but is unaffected by the color of the object and appearing
  on only one face of a box (determined by the axis of the box).</p>
<p>By default &quot;interpolate&quot; is True, but to get a sharply defined checkerboard
  in the example above, &quot;interpolate&quot; was set to False.  </p>
<p>In the example program texture_and_lighting.py you will find a creation of
  a beach ball using spherical mapping. In the example program stonehenge.py
  you will see an example of a display of a color photograph on a box. </p>
<h3>Lighting</h3>
<p>In previous versions of Visual, lights were 
  restricted to being very distant from the scene (&quot;at infinity&quot;).
  Now you  can create lights that are local, near other objects. The following
  statement creates a yellow light positioned  at (x,y,z):</p>
<blockquote>
  <p>lamp = local_light(pos=(x,y,z), color=color.yellow)</p>
</blockquote>
<p>If you continually update lamp.pos, the light will move.</p>
<p>If you want to disable all of the  lights, say scene.lights = [], making 
  an empty list of  lights.</p>
<p>A distant red light located in the direction (x,y,z) is created like this:</p>
<blockquote>
  <p>distant_light(direction=(x,y,z), color=color.red)</p>
</blockquote>
<h3>New frame option: visible</h3>
<p>You can now make a frame visible or invisible, and all objects in the frame
  will be affected. </p>
<h3>Points object</h3>
<p>A new points object is similar to a curve, but with disconnected points. As with curve, the pos attribute is an array
  of points, and color can also be an array. If you say shape=&quot;round&quot;, the points are round, which is the default; shape=&quot;square&quot; makes square points. The size of the points is specified by points.size, and the default size is 5 (meaning a square 5  by 5, or a circular disk bounded by a 5 by 5 square). The size attribute is in screen pixels if points.size_units=&quot;pixels&quot; (the default), but if points.size=&quot;world&quot;, the size 
  is in the usual coordinates. An example of a use for the new object is for the gdots 
  displayed using visual.graph. These used to be awkward labels using the letter 
  &quot;o&quot; but have been replaced with points.</p>
<p> ??Technical caveats: If the &quot;GL_ARB_point_parameters&quot; property is 
  shown in scene.info() then type = &quot;world&quot; will work. Otherwise the 
  type is silently ignored and considered to be &quot;screen&quot;. There is an 
  implementation-defined size range for either round or square points, which is 
  not easily visible to programs at this time. Specifying a size outside this 
  range will cause it to be silently clamped internally to whatever range that 
  the hardware supports.</p>
<h3>New curve option: retain</h3>
<p>In older versions of VPython, no matter how many points were in a curve, only 1000 were displayed, selected evenly over the full set of points, in order that the display of a very long curve doesn't slow down unacceptably. In the new version this is still true but the number of points displayed is 10000. </p>
<p>The new option curve.retain = 500 means that only the 500 most recently added points of a curve will be displayed; the earlier ones are deleted. This is a nice option for having a moving object leave a tail behind itself. </p>
<h3>Nonuniform axes</h3>
<p>The option  scene.uniform = False now facilitates making graphs of functions
  and is used by the module visual.graph. The option is useful for making 2D
  displays whose x and y scale factors are different. The only objects supported
  are curve, faces, points, and label. Set the scale factors with scene.range.</p>
<h3>Fonts in labels</h3>
<p>You can now specify font='times' or 'system' or 'symbol' etc. in a label object. Unicode text is supported.
</p>
<h3>Specifying a gray</h3>
<p>For convenience you can now say color=0.7 to mean color=(0.7,0.7,0.7).</p>
<h3>Render time  </h3>
<p>If you say scene.show_rendertime = True, in the lower left of the graphics window you will see the cycle time (time between renderings of the scene) and the render time (time taken to render the scene). This can be a useful diagnostic of performance issues.</p>
<h3>New toolbar with &quot;pan&quot; mode (currently Linux only) </h3>
<p>At the top of a graphics window on Linux is a toolbar with an icon to change right-button dragging
  to &quot;pan&quot; rather than rotate (and another icon to switch back). There are also
  icons to exit the program, switch
  to or from full-screen mode, and to reset to a standard camera position.</p>
<h3>Titlebar and toolbar heights </h3>
<p>The height in pixels of the titlebar is given by display.get_titlebar_height(), and the height of the toolbar (currently Linux only) is given by display.get_toolbar_height(). These values are true for all windows, and these functions are associated with the display class of objects, not with individual displays such as the standard scene, so scene.get_titlebar_height() won't work.</p>
<h3><a name="bugs"></a>Known bugs in this beta version</h3>
<p>Here are known bugs:</p>
<blockquote>
  <p>scene.cursor.visible is not implemented and gives an error.</p>
</blockquote>
<p><a href="index.html">Back to contents</a><br>
</p>
</body>
</html>
